Arborescence (profondeur max 4, sans node_modules) :
.
├── data
│   └── noms.js
├── index.html
├── javascript
│   ├── ascenseur
│   │   ├── ascenseur_controller.js
│   │   ├── ascenseur_modele.js
│   │   └── ascenseur_view.js
│   ├── calendrier
│   │   ├── calendrier_controller.js
│   │   ├── calendrier_modele.js
│   │   └── calendrier_view.js
│   └── covoiturage
│       ├── covoiturage_controller.js
│       ├── covoiturage_modele.js
│       └── covoiturage_view.js
├── projet.txt
└── utils
    ├── GestionUIJS.js
    └── utils.js

7 directories, 14 files



# ./data/noms.js
window.NOMS_POOL = [
	"Pierre Martin",
	"Marie Bernard",
	"Jean Dubois",
	"Sophie Laurent",
	"Nicolas Lefebvre",
	"Claire Moreau",
	"Thomas Simon",
	"Julie Michel",
	"Antoine Garcia",
	"Laura Petit",
	"Lucas Roux",
	"Emma Fontaine",
	"Mathieu Lambert",
	"Camille Faure",
	"Hugo Blanc",
	"Chloé Barbier",
	"Adrien Guérin",
	"Manon Henry",
	"Romain Robert",
	"Léa Mathieu",
	"Vincent Marchand",
	"Anaïs Caron",
	"Baptiste Noël",
	"Pauline Renard",
	"Alexandre Girard",
	"Charlotte Roy",
	"Julien Nicolas",
	"Marion Dupont",
	"Quentin Colin",
	"Sarah Gauthier",
	"Maxime Masson",
	"Élodie Perrin",
	"Arthur Robin",
	"Aurore Renaud",
	"Guillaume Poirier",
	"Mélanie Charles",
	"Damien Bonnet",
	"Hélène Schmitt",
	"Kévin Morel",
	"Élise Morin",
	"Florian Étienne",
	"Marine Leclerc",
	"Yann Deschamps",
	"Audrey Lefèvre",
	"Stéphane Dumas",
	"Nadia Benali",
	"Pascal Leroy",
	"Isabelle Lucas",
	"Cédric Meyer",
	"Sandrine Chartier",
	"Gaël Boucher",
	"Nora Diallo",
	"Sébastien Chauvin",
	"Ingrid Pelletier",
	"Olivier Carpentier",
	"Valérie Pruvost",
	"Loïc Perrot",
	"Amélie Daniel",
	"Jérôme Marin",
	"Caroline Georges",
	"Laurent Barre",
	"Estelle Maillard",
	"Benoît André",
	"Aline Michaud",
	"Théo Bernardin",
	"Justine Rolland",
	"Lucas Dupuy",
	"Clara Lemaire",
	"Paul Aubert",
	"Inès Le Gall",
	"Victor Pons",
	"Mélissa Cohen",
	"Gaspard Lefort",
	"Eva Bourdon",
	"Simon Collet",
	"Mathilde Boulanger",
	"Nathan Marty",
	"Alice Hébert",
	"Raphaël Louvet",
	"Nina Tessier",
	"Éric Martel",
	"Océane Lemaître",
	"Tristan Roger",
	"Margot Millet",
	"Sacha Humbert",
	"Zoé Delorme",
	"Rémi Alexandre",
	"Agathe Paris",
	"Léo Marchal",
	"Aurélie Besnard",
	"Maël Renou",
	"Noémie Leblanc",
	"Arnaud Allard",
	"Salomé Barret",
	"Émile Joly",
	"Camille Dupuis",
	"Idriss Ben Amar",
	"Aïcha Zeroual",
	"Mehdi Belkacem",
	"Yasmine Aït-Salem",
];

# ./data/noms.js

# ./index.html
<!doctype html>
<html lang="fr">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Planificateur</title>
	<!-- Bootstrap 5 CDN -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<style>
		body {
			padding-top: 1rem;
		}

		.sticky-actions {
			position: sticky;
			bottom: 0;
			background: #fff;
			padding: 1rem 0;
		}

		.group-split {
			color: #b02a37;
			font-weight: 600;
		}

		.smallcaps {
			font-variant: small-caps;
		}

		.card-elevator {
			min-width: 320px;
		}

		.table-fixed {
			table-layout: fixed;
		}

		.table-fixed td,
		.table-fixed th {
			word-wrap: break-word;
		}

		details>summary {
			cursor: pointer;
		}
	</style>
</head>

<body>
	<div class="container-xxl">
		<ul class="nav nav-tabs mb-3" id="mainTabs" role="tablist">
			<li class="nav-item" role="presentation">
				<button class="nav-link active" id="tab-elevators" data-bs-toggle="tab" data-bs-target="#pane-elevators"
					type="button" role="tab">Ascenseurs</button>
			</li>
			<li class="nav-item" role="presentation">
				<button class="nav-link" id="tab-convoiturage" data-bs-toggle="tab" data-bs-target="#pane-convoiturage"
					type="button" role="tab">Convoiturage</button>
			</li>
			<li class="nav-item" role="presentation">
				<button class="nav-link" id="tab-calendrider" data-bs-toggle="tab" data-bs-target="#pane-calendrider"
					type="button" role="tab">Calendrider personnel</button>
			</li>
			<li class="nav-item" role="presentation">
				<button class="nav-link" id="tab-interop" data-bs-toggle="tab" data-bs-target="#pane-interop" type="button"
					role="tab">
					Optimiser des emploi du temps interdépendants
				</button>
			</li>

		</ul>

		<div class="tab-content">
			<!-- L'onglet 1 est rendu par elevators.js -->
			<div class="tab-pane fade show active" id="pane-elevators" role="tabpanel" aria-labelledby="tab-elevators">
			</div>

			<!-- Convoiturage -->
			<div class="tab-pane fade" id="pane-convoiturage" role="tabpanel" aria-labelledby="tab-convoiturage"></div>

			<!-- Placeholder onglet 3 -->
			<div class="tab-pane fade" id="pane-calendrider" role="tabpanel" aria-labelledby="tab-calendrider">
				<p class="text-muted">Contenu du calendrider personnel.</p>
			</div>
			<div class="tab-pane fade" id="pane-interop" role="tabpanel" aria-labelledby="tab-interop">
				<p class="text-muted">Contenu de l’optimisation des emplois du temps interdépendants.</p>
			</div>
		</div>
	</div>

	<!-- Bootstrap JS -->
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

	<!-- Import ES module sans Node.js -->
	<script src="./data/noms.js"></script>
	<script src="./utils/GestionUIJS.js"></script>
	<script src="./utils/utils.js"></script>

	<!-- Ascenseur -->
	<script src="./javascript/ascenseur/ascenseur_modele.js"></script>
	<script src="./javascript/ascenseur/ascenseur_view.js"></script>
	<script src="./javascript/ascenseur/ascenseur_controller.js"></script>

	<!-- Convoiturage -->
	<script src="./javascript/covoiturage/covoiturage_modele.js"></script>
	<script src="./javascript/covoiturage/covoiturage_view.js"></script>
	<script src="./javascript/covoiturage/covoiturage_controller.js"></script>

	<!-- Calendrier personnel -->
	<script src="./javascript/calendrier/calendrier_modele.js"></script>
	<script src="./javascript/calendrier/calendrier_view.js"></script>
	<script src="./javascript/calendrier/calendrier_controller.js"></script>

	<script>
		window.addEventListener('DOMContentLoaded', function () {
			// Onglet 1 : Ascenseurs
			var mount1 = document.getElementById('pane-elevators');
			window.initElevators({mount: mount1});

			// Onglet 2 : Convoiturage
			var mount2 = document.getElementById('pane-convoiturage');
			window.initConvoiturage({mount: mount2});

			// Onglet 3 : calendrider personnel
			var mount3 = document.getElementById('pane-calendrider');
			window.initCalendrier({mount: mount3});
		});
	</script>
</body>

</html>

# ./index.html

# ./javascript/ascenseur/ascenseur_controller.js
/* ascenseur_controller.js — Contrôleur (ES5, 2014) */
(function (window) {
	"use strict";

	var Modele = window.AscenseurModele;
	var View = window.AscenseurView;

	// API publique conservée
	window.initElevators = function initElevators(opts) {
		if (!opts || !opts.mount) throw new Error("initElevators: {mount} requis.");

		var ui = View.createUI({ mount: opts.mount });

		// Écouteurs
		ui.cFloors.input.addEventListener("change", function () {
			var max = Math.max(1, parseInt(ui.cFloors.input.value, 10) || 1);
			ui.elevList.setMaxFor("maxFloor", max);
			ui.groupsTbl.setMaxFor("dest", max);
		});

		ui.btnAdd.button.addEventListener("click", function () {
			const val = parseInt(ui.cFloors.input.value, 10) || 5;
			console.log(">>> Valeur lue dans #elev-floors :", ui.cFloors.input.value);
			console.log(">>> Valeur convertie utilisée pour maxFloor :", val);

			ui.elevList.setMaxFor("maxFloor", val);

			ui.elevList.add({
				capacity: 2,
				start: 0,
				maxFloor: val,
				evenOnly: false,
				oddOnly: false,
			});
		});

		ui.cGroups.input.addEventListener("change", function () {
			ui.groupsTbl.setRowCount(Math.max(1, parseInt(ui.cGroups.input.value, 10) || 1));
			ui.groupsTbl.rerollRandoms();
		});

		ui.btnReg.button.addEventListener("click", function () {
			ui.groupsTbl.rerollRandoms();
		});

		ui.btnCompute.addEventListener("click", function () {
			var stateRaw = ui.collectState();
			var validation = Modele.validateState(stateRaw);
			if (!validation.ok) {
				window.GestionUI.alert(ui.spanAlert, "danger", validation.message);
				ui.results.innerHTML = "";
				return;
			}
			var state = Modele.attachPeopleToGroups(stateRaw);
			var itemsWrap = Modele.partitionGroups(state);
			var plan = Modele.assignItemsToTrips(itemsWrap.items, state);
			View.renderPlan(ui.results, plan, state);
			window.GestionUI.alert(ui.spanAlert, "success", "Plan généré.");
		});
	};
})(window);

# ./javascript/ascenseur/ascenseur_controller.js

# ./javascript/ascenseur/ascenseur_modele.js
/* ascenseur_modele.js — Modèle (ES5, 2014) */
(function (window) {
	"use strict";

	var NAME_POOL = window.NOMS_POOL || [];
	var nameCounter = 0;

	function nextPersonName() {
		var base = NAME_POOL[nameCounter % NAME_POOL.length];
		var round = Math.floor(nameCounter / NAME_POOL.length);
		nameCounter++;
		return round === 0 ? base : base + " (" + (round + 1) + ")";
	}

	/* ========= logique métier ========= */
	function validateState(state) {
		if (!state.elevators || !state.elevators.length) return { ok: false, message: "Ajoutez au moins un ascenseur." };
		// Étages uniques
		var seen = {},
			i;
		for (i = 0; i < state.groups.length; i++) seen[state.groups[i].dest] = true;
		for (var k in seen)
			if (seen.hasOwnProperty(k)) {
				var f = parseInt(k, 10),
					ok = false;
				for (i = 0; i < state.elevators.length; i++) {
					if (elevatorCanServeFloor(state.elevators[i], f)) {
						ok = true;
						break;
					}
				}
				if (!ok) return { ok: false, message: "Aucun ascenseur ne dessert l’étage " + f + " (parité/hauteur)." };
			}
		return { ok: true };
	}

	function elevatorCanServeFloor(elevator, floor) {
		if (!elevator || elevator.maxFloor < floor) return false;
		if (elevator.evenOnly && floor % 2 !== 0) return false;
		if (elevator.oddOnly && floor % 2 !== 1) return false;
		return true;
	}

	function attachPeopleToGroups(state) {
		nameCounter = 0;
		var groups = [],
			i,
			p;
		for (i = 0; i < state.groups.length; i++) {
			var g = state.groups[i],
				people = [];
			for (p = 0; p < g.size; p++) people.push({ name: nextPersonName(), dest: g.dest, groupId: g.id });
			groups.push({ id: g.id, size: g.size, dest: g.dest, people: people });
		}
		return { floors: state.floors, elevators: state.elevators, groups: groups };
	}

	function partitionGroups(state) {
		var items = [],
			i,
			e;
		for (i = 0; i < state.groups.length; i++) {
			var g = state.groups[i],
				bestCap = 0;
			for (e = 0; e < state.elevators.length; e++) {
				var el = state.elevators[e];
				if (elevatorCanServeFloor(el, g.dest) && el.capacity > bestCap) bestCap = el.capacity;
			}
			if (g.size <= bestCap) {
				items.push({ groupId: g.id, partIndex: 1, parts: 1, size: g.size, dest: g.dest, people: g.people.slice(0) });
			} else {
				var parts = Math.ceil(g.size / bestCap),
					remaining = g.size,
					offset = 0,
					p,
					take,
					slice;
				for (p = 1; p <= parts; p++) {
					take = Math.min(bestCap, remaining);
					slice = g.people.slice(offset, offset + take);
					items.push({ groupId: g.id, partIndex: p, parts: parts, size: take, dest: g.dest, people: slice, forced: true });
					remaining -= take;
					offset += take;
				}
			}
		}
		items.sort(function (a, b) {
			return b.dest - a.dest || b.size - a.size;
		});
		return { items: items };
	}

	function assignItemsToTrips(items, state) {
		var openTrips = [],
			trips = [],
			tCounter = 0;
		var tripsPerElevator = {},
			i,
			e;
		for (e = 0; e < state.elevators.length; e++) tripsPerElevator[state.elevators[e].id] = 0;

		for (i = 0; i < items.length; i++) {
			var it = items[i],
				best = null,
				bestWaste = Infinity,
				ot,
				t;
			for (ot = 0; ot < openTrips.length; ot++) {
				t = openTrips[ot];
				if (t.capLeft >= it.size && elevatorCanServeFloor(getElevatorById(state.elevators, t.elevatorId), it.dest)) {
					var waste = t.capLeft - it.size;
					if (waste < bestWaste) {
						bestWaste = waste;
						best = t;
					}
				}
			}
			var chosen = best;
			if (!chosen) {
				var chosenElev = null;
				for (e = 0; e < state.elevators.length; e++) {
					var el = state.elevators[e];
					if (!elevatorCanServeFloor(el, it.dest)) continue;
					if (!chosenElev) chosenElev = el;
					else if (el.capacity > chosenElev.capacity) chosenElev = el;
					else if (el.capacity === chosenElev.capacity && (tripsPerElevator[el.id] || 0) < (tripsPerElevator[chosenElev.id] || 0)) chosenElev = el;
				}
				chosen = { id: ++tCounter, elevatorId: chosenElev.id, capLeft: chosenElev.capacity, maxCap: chosenElev.capacity, stops: [], items: [] };
				openTrips.push(chosen);
				tripsPerElevator[chosenElev.id] = (tripsPerElevator[chosenElev.id] || 0) + 1;
			}
			chosen.items.push(it);
			chosen.capLeft -= it.size;
			addStopUnique(chosen.stops, it.dest);
			if (chosen.capLeft === 0) closeTrip(chosen);
		}
		for (var k = openTrips.length - 1; k >= 0; k--) closeTrip(openTrips[k]);

		function closeTrip(t) {
			t.stops.sort(function (a, b) {
				return a - b;
			});
			trips.push({ id: t.id, elevatorId: t.elevatorId, capacity: t.maxCap, stops: t.stops.slice(0), items: t.items.slice(0) });
			var idx = indexOfTrip(openTrips, t);
			if (idx >= 0) openTrips.splice(idx, 1);
		}
		trips.sort(function (a, b) {
			var d = a.elevatorId - b.elevatorId;
			return d !== 0 ? d : maxOfArray(b.stops) - maxOfArray(a.stops);
		});
		return trips;
	}

	/* ========= helpers (modèle) ========= */
	function addStopUnique(stops, floor) {
		for (var i = 0; i < stops.length; i++) if (stops[i] === floor) return;
		stops.push(floor);
	}
	function getElevatorById(arr, id) {
		for (var i = 0; i < arr.length; i++) if (arr[i].id === id) return arr[i];
		return null;
	}
	function indexOfTrip(arr, t) {
		for (var i = 0; i < arr.length; i++) if (arr[i] === t) return i;
		return -1;
	}
	function maxOfArray(a) {
		if (!a.length) return -Infinity;
		var m = a[0];
		for (var i = 1; i < a.length; i++) if (a[i] > m) m = a[i];
		return m;
	}
	function clampInt(v, min, max) {
		var n = Math.floor(Number(v) || 0);
		if (n < min) n = min;
		if (n > max) n = max;
		return n;
	}

	/* ========= export ========= */
	window.AscenseurModele = {
		validateState: validateState,
		elevatorCanServeFloor: elevatorCanServeFloor,
		attachPeopleToGroups: attachPeopleToGroups,
		partitionGroups: partitionGroups,
		assignItemsToTrips: assignItemsToTrips,
		clampInt: clampInt,
		getElevatorById: getElevatorById,
	};
})(window);

# ./javascript/ascenseur/ascenseur_modele.js

# ./javascript/ascenseur/ascenseur_view.js
/* ascenseur_view.js — Vue (ES5, 2014) */
(function (window, document) {
	"use strict";

	/* ========= construction UI ========= */
	function createUI(opts) {
		if (!opts || !opts.mount) throw new Error("AscenseurView.createUI: {mount} requis.");
		var mount = opts.mount;

		// Barre de paramètres
		var row = document.createElement("div");
		row.className = "row g-3 align-items-end mb-3";
		var cFloors = colControl("Nombre d'étages (0 à N)", "number", "elev-floors", 5, { min: 1 });
		var btnAdd = buttonControl("Ajouter un ascenseur", "elev-btnAddElevator", "btn btn-outline-primary");
		var cGroups = colControl("Nombre de groupes", "number", "elev-groupCount", 1, { min: 1 });
		var btnReg = buttonControl("Régénérer les groupes", "elev-btnRegenerateGroups", "btn btn-outline-secondary");
		row.appendChild(cFloors.col);
		row.appendChild(btnAdd.col);
		row.appendChild(cGroups.col);
		row.appendChild(btnReg.col);
		mount.appendChild(row);

		// Liste des ascenseurs
		var listHost = document.createElement("div");
		listHost.className = "mb-4";
		mount.appendChild(listHost);
		var elevList = window.GestionUI.listEditor(listHost, {
			title: "Ascenseur",
			addLabel: "Ajouter un ascenseur",
			fields: [
				{ key: "capacity", label: "Capacité max", type: "number", min: 1, value: 2 },
				{ key: "start", label: "Étage de départ", type: "number", min: 0, value: 0 },
				{ key: "maxFloor", label: "Étage max desservi", type: "number", min: 0, max: 5, value: 5 },
			],
			checks: [
				{ key: "evenOnly", label: "Dessert uniquement les étages pairs", exclusiveWith: "oddOnly" },
				{ key: "oddOnly", label: "Dessert uniquement les étages impairs", exclusiveWith: "evenOnly" },
			],
			initial: [{ capacity: 2, start: 0, maxFloor: 5, evenOnly: false, oddOnly: false }],
			idKey: "id",
		});

		// Groupes
		var groupsHost = document.createElement("div");
		mount.appendChild(groupsHost);
		var groupsTbl = window.GestionUI.tableEditor(groupsHost, {
			title: "Groupes (départ RDC = 0)",
			rowLabel: "Groupe",
			initialRows: 1,
			columns: [
				{ key: "size", label: "Taille (personnes)", type: "number", min: 1, max: 4, value: 1, defaultRandom: true },
				{ key: "dest", label: "Étage d'arrivée", type: "number", min: 1, value: 1, defaultRandom: true },
			],
			randomizeRow: function (col) {
				if (col.key === "size") return window.random_int(col.min || 1, col.max || 4);
				if (col.key === "dest") {
					var floors = parseInt(document.getElementById("elev-floors").value, 10) || 5;
					return window.random_int(col.min || 1, floors);
				}
				return "";
			},
		});

		// Actions
		var actions = document.createElement("div");
		actions.className = "sticky-actions border-top";
		var btnCompute = document.createElement("button");
		btnCompute.className = "btn btn-lg btn-primary";
		btnCompute.textContent = "Générer le résultat";
		var spanAlert = document.createElement("span");
		spanAlert.id = "elev-computeAlert";
		spanAlert.className = "ms-3";
		actions.appendChild(btnCompute);
		actions.appendChild(spanAlert);
		mount.appendChild(actions);

		// Résultats
		var results = document.createElement("div");
		results.id = "elev-results";
		results.className = "mt-4";
		mount.appendChild(results);

		function collectState() {
			var floors = Math.max(1, parseInt(cFloors.input.value, 10) || 1);
			var elevators = elevList.getData();
			for (var i = 0; i < elevators.length; i++) {
				if (elevators[i].maxFloor > floors) elevators[i].maxFloor = floors;
			}
			var groups = groupsTbl.getData();
			return { floors: floors, elevators: elevators, groups: groups };
		}

		return {
			mount: mount,
			cFloors: cFloors,
			btnAdd: btnAdd,
			cGroups: cGroups,
			btnReg: btnReg,
			btnCompute: btnCompute,
			spanAlert: spanAlert,
			results: results,
			elevList: elevList,
			groupsTbl: groupsTbl,
			collectState: collectState,
		};
	}

	/* ========= rendu ========= */
	function renderPlan(mount, trips, state) {
		var split = {},
			t,
			i;
		for (t = 0; t < trips.length; t++)
			for (i = 0; i < trips[t].items.length; i++) {
				var gid = trips[t].items[i].groupId;
				split[gid] = (split[gid] || 0) + 1;
			}
		var actuallySplit = 0;
		for (var g in split) if (split.hasOwnProperty(g) && split[g] > 1) actuallySplit++;

		var kpis =
			'<div class="row g-3 mb-3">' +
			' <div class="col-auto"><div class="badge text-bg-primary p-3">Allers‑retours totaux&nbsp;: <strong>' +
			trips.length +
			"</strong></div></div>" +
			' <div class="col-auto"><div class="badge text-bg-secondary p-3">Groupes séparés&nbsp;: <strong>' +
			actuallySplit +
			"</strong></div></div>" +
			' <div class="col-auto"><div class="badge text-bg-light border p-3">Étages max immeuble&nbsp;: <strong>' +
			state.floors +
			"</strong></div></div>" +
			"</div>";

		var thead =
			'<thead class="table-light"><tr>' +
			'<th style="width:70px;">#</th><th style="width:110px;">Ascenseur</th><th style="width:110px;">Capacité</th>' +
			'<th>Groupes embarqués</th><th style="width:210px;">Étages desservis</th><th style="width:220px;">Remarques</th>' +
			"</tr></thead>";

		var rows = "";
		for (t = 0; t < trips.length; t++) {
			var trip = trips[t];
			var e = getElevatorById(state.elevators, trip.elevatorId);
			var groupsHtml = "";
			for (i = 0; i < trip.items.length; i++) {
				var it = trip.items[i];
				var title = "G" + it.groupId + (it.parts > 1 ? " (part " + it.partIndex + "/" + it.parts + ")" : "") + " : " + it.size + "p → " + it.dest;
				var names = [];
				if (it.people) for (var n = 0; n < it.people.length; n++) names.push(it.people[n].name);
				groupsHtml +=
					'<div class="mb-2"><div>' +
					escapeHtml(title) +
					"</div>" +
					"<details><summary>" +
					it.size +
					" personne(s)</summary><small>" +
					(names.length ? escapeHtml(names.join(", ")) : "—") +
					"</small></details></div>";
			}
			var stopsTxt = trip.stops.length ? "0 → " + trip.stops.join(" → ") + " → 0" : "—";
			var remarks = [];
			if (e.start !== 0) remarks.push("Départ réel à l’étage " + e.start);
			if (e.evenOnly) remarks.push("Pairs uniquement");
			if (e.oddOnly) remarks.push("Impairs uniquement");
			var hasSplit = false;
			for (i = 0; i < trip.items.length; i++)
				if (trip.items[i].parts > 1) {
					hasSplit = true;
					break;
				}
			if (hasSplit) remarks.push('<span class="group-split">Séparation nécessaire</span>');

			rows +=
				"<tr><td>" +
				(t + 1) +
				"</td><td>#" +
				e.id +
				"</td><td>" +
				trip.capacity +
				" p</td>" +
				"<td>" +
				groupsHtml +
				"</td><td>" +
				stopsTxt +
				"</td><td>" +
				(remarks.length ? remarks.join("<br>") : "—") +
				"</td></tr>";
		}

		mount.innerHTML =
			kpis +
			'<div class="card"><div class="card-header">Séquence optimale (heuristique)</div>' +
			'<div class="card-body p-0"><div class="table-responsive"><table class="table table-striped table-hover align-middle table-fixed mb-0">' +
			thead +
			"<tbody>" +
			(rows || '<tr><td colspan="6" class="text-center text-muted">Aucun trajet nécessaire</td></tr>') +
			"</tbody></table></div></div>" +
			'<div class="card-footer text-muted">Objectif&nbsp;: minimiser les allers‑retours puis éviter les séparations. Les groupes ne sont séparés que si la capacité maximale des ascenseurs le rend inévitable.</div>' +
			"</div>";
	}

	/* ========= helpers (vue) ========= */
	function colControl(label, type, id, val, attrs) {
		var col = document.createElement("div");
		col.className = "col-auto";
		var lab = document.createElement("label");
		lab.className = "form-label";
		lab.setAttribute("for", id);
		lab.textContent = label;
		var inp = document.createElement("input");
		inp.className = "form-control";
		inp.id = id;
		inp.type = type || "text";
		inp.value = val || "";
		if (attrs) for (var k in attrs) if (attrs.hasOwnProperty(k)) inp.setAttribute(k, attrs[k]);
		col.appendChild(lab);
		col.appendChild(inp);
		return { col: col, input: inp };
	}
	function buttonControl(text, id, klass) {
		var col = document.createElement("div");
		col.className = "col-auto";
		var btn = document.createElement("button");
		btn.className = klass || "btn btn-secondary";
		btn.id = id;
		btn.type = "button";
		btn.textContent = text;
		col.appendChild(btn);
		return { col: col, button: btn };
	}
	function getElevatorById(arr, id) {
		for (var i = 0; i < arr.length; i++) if (arr[i].id === id) return arr[i];
		return null;
	}
	function escapeHtml(s) {
		return String(s).replace(/[&<>"']/g, function (m) {
			return { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[m];
		});
	}

	/* ========= export ========= */
	window.AscenseurView = {
		createUI: createUI,
		renderPlan: renderPlan,
	};
})(window, document);

# ./javascript/ascenseur/ascenseur_view.js

# ./javascript/calendrier/calendrier_controller.js
/* calendrier_controller.js — Contrôleur (ES5) */
(function (window) {
	"use strict";

	var Modele = window.CalendrierModele;

	window.initCalendrier = function initCalendrier(opts) {
		if (!opts || !opts.mount) throw new Error("initCalendrier: {mount} requis.");

		var state = Modele.loadAll();
		if (!state.currentProfileKey || !Object.keys(state.profils).length) {
			Modele.createProfile(state);
			Modele.saveAll(state);
		}

		var view = window.CalendrierView.createUI({ mount: opts.mount });
		var ctx = (function () {
			var t = new Date();
			return { y: t.getFullYear(), m: t.getMonth() };
		})();

		function refreshProfilesSelect() {
			var sel = view.profileSelect;
			sel.innerHTML = "";
			var keys = Object.keys(state.profils);
			for (var i = 0; i < keys.length; i++) {
				var k = keys[i],
					p = state.profils[k];
				var op = document.createElement("option");
				op.value = k;
				op.textContent = p.name || "Profil " + (i + 1);
				if (k === state.currentProfileKey) op.selected = true;
				sel.appendChild(op);
			}
		}
		function currentProfile() {
			return Modele.getCurrentProfile(state);
		}

		function renderAll() {
			var p = currentProfile();
			if (!p) return;
			view.renderMonth({ y: ctx.y, m: ctx.m, profile: p });
			var evts = p.events.slice(0).sort(function (a, b) {
				return +new Date(a.startISO) - +new Date(b.startISO);
			});
			view.updateEventChoices(evts);
			view.renderTasks(p);
			Modele.saveAll(state);
		}
		function setToday() {
			var t = new Date();
			ctx.y = t.getFullYear();
			ctx.m = t.getMonth();
			renderAll();
		}

		/* Profils */
		refreshProfilesSelect();
		view.profileSelect.addEventListener("change", function () {
			Modele.setCurrentProfile(state, this.value);
			renderAll();
		});
		view.btnNewProfile.addEventListener("click", function () {
			Modele.createProfile(state);
			refreshProfilesSelect();
			renderAll();
		});
		view.btnRenameProfile.addEventListener("click", function () {
			if (!state.currentProfileKey) return;
			var curr = currentProfile();
			var name = prompt("Nouveau nom du profil :", curr.name || "");
			if (!name) return;
			Modele.renameProfile(state, state.currentProfileKey, name.trim());
			Modele.saveAll(state);
			refreshProfilesSelect();
			renderAll();
		});
		view.btnDeleteProfile.addEventListener("click", function () {
			if (!state.currentProfileKey) return;
			if (!confirm("Supprimer le profil courant ?")) return;
			Modele.deleteProfile(state, state.currentProfileKey);
			refreshProfilesSelect();
			renderAll();
		});

		/* Nav */
		view.btnPrev.addEventListener("click", function () {
			ctx.m -= 1;
			if (ctx.m < 0) {
				ctx.m = 11;
				ctx.y -= 1;
			}
			renderAll();
		});
		view.btnNext.addEventListener("click", function () {
			ctx.m += 1;
			if (ctx.m > 11) {
				ctx.m = 0;
				ctx.y += 1;
			}
			renderAll();
		});
		view.btnToday.addEventListener("click", setToday);

		/* CRUD évènements */
		var form = view.getForm();
		view.onSaveDelete(saveEvent, deleteEvent);

		function parseFormToEvent(existingId) {
			var ymd = String(form.date.value || "");
			if (!ymd) return null;
			var p = ymd.split("-");
			var y = +p[0],
				m = +p[1] - 1,
				d = +p[2];
			function hm(v, def) {
				v = v || def;
				return { h: +v.slice(0, 2), m: +v.slice(3, 5) };
			}
			var s = hm(form.start.value, "09:00"),
				e = hm(form.end.value, "10:00");
			return {
				id: existingId || null,
				startISO: new Date(y, m, d, s.h, s.m, 0, 0).toISOString(),
				endISO: new Date(y, m, d, e.h, e.m, 0, 0).toISOString(),
				title: String(form.title.value || ""),
				attendeesCsv: String(form.people.value || ""),
				content: String(form.content.value || ""),
				subtasks: [],
			};
		}
		function pad2(n) {
			return (n < 10 ? "0" : "") + n;
		}

		function saveEvent() {
			var key = state.currentProfileKey;
			if (!key) return;
			var isEdit = !!form.id.value;
			var evt = parseFormToEvent(isEdit ? form.id.value : null);
			if (!evt) return;
			if (isEdit) {
				evt.id = form.id.value;
				Modele.updateEvent(state, key, evt);
			} else {
				Modele.addEvent(state, key, evt);
				form.id.value = evt.id;
			}

			if (form.subChk.checked) {
				evt = Modele.expandIntoSubtasks(evt, form.subN.value);
				Modele.updateEvent(state, key, evt);
			}

			var overlap = Modele.detectOverlap(currentProfile(), evt);
			if (overlap && confirm("Chevauchement détecté avec « " + (overlap.title || "(sans objet)") + " ». Proposer un déplacement ?")) {
				var prop = Modele.proposeMove(currentProfile(), evt);
				if (prop) {
					evt.startISO = prop.startISO;
					evt.endISO = prop.endISO;
					Modele.updateEvent(state, key, evt);
					alert("Évènement déplacé.");
				}
			}
			Modele.saveAll(state);
			renderAll();
		}
		function deleteEvent() {
			var key = state.currentProfileKey;
			if (!key || !form.id.value) return;
			if (!confirm("Supprimer cet évènement ?")) return;
			Modele.deleteEvent(state, key, form.id.value);
			form.id.value = "";
			Modele.saveAll(state);
			renderAll();
		}

		/* Planification */
		var plan = view.planningControls;
		plan.btnBetween.addEventListener("click", function () {
			var A = plan.selA.value,
				B = plan.selB.value;
			if (!A || !B || A === B) {
				alert("Choisir deux évènements différents.");
				return;
			}
			var draft = { durationMin: minutesBetweenForm() },
				res = Modele.planBetween(currentProfile(), A, B, draft);
			if (!res) {
				alert("Impossible de placer entre A et B.");
				return;
			}
			var s = new Date(res.startISO),
				e = new Date(res.endISO);
			form.date.value = s.toISOString().slice(0, 10);
			form.start.value = pad2(s.getHours()) + ":" + pad2(s.getMinutes());
			form.end.value = pad2(e.getHours()) + ":" + pad2(e.getMinutes());
		});
		plan.btnResolve.addEventListener("click", function () {
			var isEdit = !!form.id.value;
			var evt = parseFormToEvent(isEdit ? form.id.value : null);
			if (!evt) return;
			var prop = Modele.proposeMove(currentProfile(), evt);
			if (!prop) {
				alert("Aucune proposition trouvée.");
				return;
			}
			var s = new Date(prop.startISO),
				e = new Date(prop.endISO);
			form.date.value = s.toISOString().slice(0, 10);
			form.start.value = pad2(s.getHours()) + ":" + pad2(s.getMinutes());
			form.end.value = pad2(e.getHours()) + ":" + pad2(e.getMinutes());
		});
		plan.btnSubEvents.addEventListener("click", function () {
			form.subChk.checked = true;
			alert("Coche activée. Enregistrez pour créer les sous-tâches.");
		});
		function minutesBetweenForm() {
			var s = form.start.value || "09:00",
				e = form.end.value || "10:00";
			var sh = +s.slice(0, 2),
				sm = +s.slice(3, 5),
				eh = +e.slice(0, 2),
				em = +e.slice(3, 5);
			return eh * 60 + em - (sh * 60 + sm);
		}

		/* Tâches + commentaires */
		var tasksUI = view.tasksUI;

		tasksUI.addBtn.addEventListener("click", function () {
			var key = state.currentProfileKey;
			if (!key) return;
			var title = (tasksUI.newInput.value || "").trim();
			Modele.addTask(state, key, title);
			tasksUI.newInput.value = "";
			Modele.saveAll(state);
			renderAll();
		});

		tasksUI.newInput.addEventListener("keydown", function (e) {
			if (e.key === "Enter") {
				e.preventDefault();
				tasksUI.addBtn.click();
			}
		});

		tasksUI.list.addEventListener("change", function (ev) {
			var trow = ev.target.closest("[data-task-id]");
			if (!trow) return;
			var taskId = trow.getAttribute("data-task-id");
			if (ev.target.classList.contains("cal-task-done")) {
				Modele.toggleTask(state, state.currentProfileKey, taskId, !!ev.target.checked);
				Modele.saveAll(state);
			} else if (ev.target.classList.contains("cal-task-title")) {
				Modele.updateTaskTitle(state, state.currentProfileKey, taskId, ev.target.value);
				Modele.saveAll(state);
			}
		});

		tasksUI.list.addEventListener("input", function (ev) {
			var trow = ev.target.closest("[data-task-id]");
			if (!trow) return;
			var taskId = trow.getAttribute("data-task-id");
			if (ev.target.classList.contains("cal-task-title")) {
				Modele.updateTaskTitle(state, state.currentProfileKey, taskId, ev.target.value);
				Modele.saveAll(state);
			}
		});

		tasksUI.list.addEventListener("click", function (ev) {
			var trow = ev.target.closest("[data-task-id]");
			var key = state.currentProfileKey;
			if (!trow || !key) return;
			var taskId = trow.getAttribute("data-task-id");

			if (ev.target.classList.contains("cal-task-del")) {
				if (confirm("Supprimer cette tâche ?")) {
					Modele.deleteTask(state, key, taskId);
					Modele.saveAll(state);
					renderAll();
				}
			}
			if (ev.target.classList.contains("cal-cmt-add")) {
				var input = trow.querySelector(".cal-cmt-text");
				var txt = input ? input.value.trim() : "";
				if (!txt) return;
				Modele.addComment(state, key, taskId, txt);
				Modele.saveAll(state);
				renderAll();
			}
			if (ev.target.classList.contains("cal-cmt-edit")) {
				var crow = ev.target.closest("[data-cmt-id]");
				if (!crow) return;
				var cmtId = crow.getAttribute("data-cmt-id");
				var old = crow.querySelector("div").innerText.split("\n")[0] || "";
				var neu = prompt("Modifier le commentaire :", old);
				if (neu == null) return;
				Modele.updateComment(state, key, taskId, cmtId, neu);
				Modele.saveAll(state);
				renderAll();
			}
			if (ev.target.classList.contains("cal-cmt-del")) {
				var crow2 = ev.target.closest("[data-cmt-id]");
				if (!crow2) return;
				var cmtId2 = crow2.getAttribute("data-cmt-id");
				if (confirm("Supprimer ce commentaire ?")) {
					Modele.deleteComment(state, key, taskId, cmtId2);
					Modele.saveAll(state);
					renderAll();
				}
			}
		});

		/* Premier rendu */
		refreshProfilesSelect();
		renderAll();
	};
})(window);

# ./javascript/calendrier/calendrier_controller.js

# ./javascript/calendrier/calendrier_modele.js
/* calendrier_modele.js — Modèle (ES5) */
(function (window) {
	"use strict";

	var STORAGE_KEY = "calendrier_personnel";

	function nowFrLabel() {
		var d = new Date();
		var date = d.toLocaleDateString("fr-FR");
		var time = d.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" });
		return date + " " + time;
	}
	function uid() {
		return "e" + Math.random().toString(36).slice(2, 10);
	}

	function loadAll() {
		try {
			var raw = window.localStorage.getItem("calendrier_personnel");
			var obj = raw ? JSON.parse(raw) : { profils: {}, currentProfileKey: null };
			if (!obj || typeof obj !== "object") obj = { profils: {}, currentProfileKey: null };
			var profils = obj.profils || {};
			for (var k in profils)
				if (profils.hasOwnProperty(k)) {
					var p = profils[k] || {};
					if (!Array.isArray(p.events)) p.events = [];
					if (!Array.isArray(p.tasks)) p.tasks = [];
					for (var i = 0; i < p.events.length; i++) {
						var ev = p.events[i];
						if (!Array.isArray(ev.subtasks)) ev.subtasks = [];
					}
					profils[k] = p;
				}
			obj.profils = profils;
			return obj;
		} catch (e) {
			return { profils: {}, currentProfileKey: null };
		}
	}

	function createProfile(state, name) {
		var label = String(
			name ||
				"Profil " +
					(function nextN() {
						var max = 0,
							keys = Object.keys(state.profils || {});
						for (var i = 0; i < keys.length; i++) {
							var m = /^Profil\s+(\d+)$/.exec((state.profils[keys[i]] || {}).name || "");
							if (m) max = Math.max(max, +m[1]);
						}
						return max + 1;
					})()
		).trim();
		var createdFr = (function () {
			var d = new Date();
			return d.toLocaleDateString("fr-FR") + " " + d.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" });
		})();
		var subKey = label + " — créé le " + createdFr;
		if (state.profils[subKey]) subKey += " #" + Math.floor(Math.random() * 1000);
		state.profils[subKey] = { name: label, createdFr: createdFr, createdISO: new Date().toISOString(), events: [], tasks: [] };
		state.currentProfileKey = subKey;
		return subKey;
	}

	function renameProfile(state, key, newName) {
		if (!state.profils[key]) return;
		var label = String(newName || "").trim();
		if (!label) return;
		state.profils[key].name = label; // la clé interne ne change pas
	}

	function deleteProfile(state, key) {
		if (state.profils[key]) {
			delete state.profils[key];
			state.currentProfileKey = Object.keys(state.profils)[0] || null;
		}
	}
	function setCurrentProfile(state, key) {
		if (state.profils[key]) state.currentProfileKey = key;
	}
	function getCurrentProfile(state) {
		return state.profils[state.currentProfileKey] || null;
	}

	/* ======== Évènements ======== */
	function addEvent(state, profileKey, evt) {
		evt.id = uid();
		state.profils[profileKey].events.push(evt);
		return evt.id;
	}
	function updateEvent(state, profileKey, evt) {
		var list = state.profils[profileKey].events;
		for (var i = 0; i < list.length; i++)
			if (list[i].id === evt.id) {
				list[i] = evt;
				return true;
			}
		return false;
	}
	function deleteEvent(state, profileKey, id) {
		var list = state.profils[profileKey].events;
		for (var i = list.length - 1; i >= 0; i--) if (list[i].id === id) list.splice(i, 1);
	}
	function listEventsOnDay(profile, y, m, d) {
		var out = [];
		for (var i = 0; i < profile.events.length; i++) {
			var e = profile.events[i],
				dt = new Date(e.startISO);
			if (dt.getFullYear() === y && dt.getMonth() === m && dt.getDate() === d) out.push(e);
		}
		out.sort(function (a, b) {
			return new Date(a.startISO) - new Date(b.startISO);
		});
		return out;
	}
	function detectOverlap(profile, evt) {
		var s = +new Date(evt.startISO),
			e = +new Date(evt.endISO);
		for (var i = 0; i < profile.events.length; i++) {
			var it = profile.events[i];
			if (it.id === evt.id) continue;
			var s2 = +new Date(it.startISO),
				e2 = +new Date(it.endISO);
			if (Math.max(s, s2) < Math.min(e, e2)) return it;
		}
		return null;
	}
	function proposeMove(profile, evt) {
		var start = new Date(evt.startISO),
			end = new Date(evt.endISO);
		var day = start.getDate(),
			mon = start.getMonth(),
			yr = start.getFullYear();
		for (var tries = 48; tries-- > 0; ) {
			var clash = detectOverlap(profile, { id: evt.id, startISO: start.toISOString(), endISO: end.toISOString() });
			if (!clash && start.getDate() === day && start.getMonth() === mon && start.getFullYear() === yr) {
				return { startISO: start.toISOString(), endISO: end.toISOString() };
			}
			start = new Date(+start + 30 * 60000);
			end = new Date(+end + 30 * 60000);
		}
		return null;
	}
	function planBetween(profile, eventIdA, eventIdB, draft) {
		var A = null,
			B = null;
		for (var i = 0; i < profile.events.length; i++) {
			if (profile.events[i].id === eventIdA) A = profile.events[i];
			if (profile.events[i].id === eventIdB) B = profile.events[i];
		}
		if (!A || !B) return null;
		var aEnd = +new Date(A.endISO),
			bStart = +new Date(B.startISO);
		if (bStart <= aEnd) return null;
		var mid = new Date((aEnd + bStart) / 2);
		var durMin = Math.max(15, draft.durationMin || 30);
		var start = new Date(+mid - (durMin * 60000) / 2);
		var end = new Date(+start + durMin * 60000);
		return { startISO: start.toISOString(), endISO: end.toISOString() };
	}
	function expandIntoSubtasks(evt, n) {
		n = Math.max(1, Math.floor(Number(n) || 0));
		var subs = [];
		for (var i = 1; i <= n; i++) subs.push({ id: uid(), label: "Sous-tâche " + i, done: false });
		evt.subtasks = subs;
		return evt;
	}

	/* ======== Tâches ======== */
	function addTask(state, profileKey, title) {
		var t = { id: uid(), title: String(title || "").trim() || "Nouvelle tâche", done: false, comments: [] };
		state.profils[profileKey].tasks.push(t);
		return t.id;
	}
	function updateTaskTitle(state, profileKey, taskId, title) {
		var ts = state.profils[profileKey].tasks;
		for (var i = 0; i < ts.length; i++)
			if (ts[i].id === taskId) {
				ts[i].title = String(title || "").trim();
				return;
			}
	}
	function toggleTask(state, profileKey, taskId, done) {
		var ts = state.profils[profileKey].tasks;
		for (var i = 0; i < ts.length; i++)
			if (ts[i].id === taskId) {
				ts[i].done = !!done;
				return;
			}
	}
	function deleteTask(state, profileKey, taskId) {
		var ts = state.profils[profileKey].tasks;
		for (var i = ts.length - 1; i >= 0; i--) if (ts[i].id === taskId) ts.splice(i, 1);
	}
	function addComment(state, profileKey, taskId, text) {
		var ts = state.profils[profileKey].tasks;
		for (var i = 0; i < ts.length; i++)
			if (ts[i].id === taskId) {
				ts[i].comments.push({ id: uid(), text: String(text || "").trim(), createdISO: new Date().toISOString() });
				return;
			}
	}
	function updateComment(state, profileKey, taskId, commentId, text) {
		var ts = state.profils[profileKey].tasks;
		for (var i = 0; i < ts.length; i++)
			if (ts[i].id === taskId) {
				var cs = ts[i].comments;
				for (var j = 0; j < cs.length; j++)
					if (cs[j].id === commentId) {
						cs[j].text = String(text || "").trim();
						cs[j].updatedISO = new Date().toISOString();
						return;
					}
			}
	}
	function deleteComment(state, profileKey, taskId, commentId) {
		var ts = state.profils[profileKey].tasks;
		for (var i = 0; i < ts.length; i++)
			if (ts[i].id === taskId) {
				var cs = ts[i].comments;
				for (var j = cs.length - 1; j >= 0; j--) if (cs[j].id === commentId) cs.splice(j, 1);
				return;
			}
	}

	window.CalendrierModele = {
		STORAGE_KEY: STORAGE_KEY,
		loadAll: loadAll,
		saveAll: saveAll,
		createProfile: createProfile,
		renameProfile: renameProfile,
		deleteProfile: deleteProfile,
		setCurrentProfile: setCurrentProfile,
		getCurrentProfile: getCurrentProfile,
		addEvent: addEvent,
		updateEvent: updateEvent,
		deleteEvent: deleteEvent,
		listEventsOnDay: listEventsOnDay,
		detectOverlap: detectOverlap,
		proposeMove: proposeMove,
		planBetween: planBetween,
		expandIntoSubtasks: expandIntoSubtasks,
		addTask: addTask,
		updateTaskTitle: updateTaskTitle,
		toggleTask: toggleTask,
		deleteTask: deleteTask,
		addComment: addComment,
		updateComment: updateComment,
		deleteComment: deleteComment,
	};
})(window);

# ./javascript/calendrier/calendrier_modele.js

# ./javascript/calendrier/calendrier_view.js
/* calendrier_view.js — Vue (ES5) */
(function (window, document) {
	"use strict";

	function pad2(n) {
		return (n < 10 ? "0" : "") + n;
	}
	function formatTime(dt) {
		return pad2(dt.getHours()) + ":" + pad2(dt.getMinutes());
	}
	function weekdayNames() {
		return ["Lun", "Mar", "Mer", "Jeu", "Ven", "Sam", "Dim"];
	}
	function ucFirstFr(s) {
		return s.slice(0, 1).toLocaleUpperCase("fr-FR") + s.slice(1);
	}

	function createUI(opts) {
		if (!opts || !opts.mount) throw new Error("CalendrierView.createUI: {mount} requis.");
		var mount = opts.mount;
		mount.innerHTML = "";

		/* Barre profils */
		var bar = document.createElement("div");
		bar.className = "d-flex align-items-end flex-wrap gap-3 mb-3";
		var profGroup = document.createElement("div");
		profGroup.className = "d-flex align-items-end gap-2";
		var labP = document.createElement("label");
		labP.className = "form-label small mb-0";
		labP.textContent = "Profil";
		var selP = document.createElement("select");
		selP.className = "form-select";
		selP.style.minWidth = "280px";
		var btnNewP = document.createElement("button");
		btnNewP.className = "btn btn-outline-primary";
		btnNewP.type = "button";
		btnNewP.textContent = "Nouveau profil +";
		var btnRenP = document.createElement("button");
		btnRenP.className = "btn btn-outline-secondary";
		btnRenP.type = "button";
		btnRenP.textContent = "Renommer";
		var btnDelP = document.createElement("button");
		btnDelP.className = "btn btn-outline-danger";
		btnDelP.type = "button";
		btnDelP.textContent = "Supprimer le profil";
		profGroup.appendChild(labP);
		profGroup.appendChild(selP);
		profGroup.appendChild(btnNewP);
		profGroup.appendChild(btnRenP);
		profGroup.appendChild(btnDelP);

		/* Nav mois */
		var nav = document.createElement("div");
		nav.className = "d-flex align-items-center gap-2 ms-auto";
		var btnPrev = document.createElement("button");
		btnPrev.className = "btn btn-outline-secondary";
		btnPrev.type = "button";
		btnPrev.textContent = "‹";
		var title = document.createElement("h5");
		title.className = "mb-0";
		var btnNext = document.createElement("button");
		btnNext.className = "btn btn-outline-secondary";
		btnNext.type = "button";
		btnNext.textContent = "›";
		var btnToday = document.createElement("button");
		btnToday.className = "btn btn-outline-secondary";
		btnToday.type = "button";
		btnToday.textContent = "Aujourd’hui";
		nav.appendChild(btnPrev);
		nav.appendChild(title);
		nav.appendChild(btnNext);
		nav.appendChild(btnToday);

		bar.appendChild(profGroup);
		bar.appendChild(nav);
		mount.appendChild(bar);

		/* Grille + éditeur + tâches */
		var row = document.createElement("div");
		row.className = "row g-3";

		// Grille
		var colGrid = document.createElement("div");
		colGrid.className = "col-lg-8";
		var gridCard = document.createElement("div");
		gridCard.className = "card";
		var gridHead = document.createElement("div");
		gridHead.className = "card-header";
		gridHead.textContent = "Calendrier (mois)";
		var gridBody = document.createElement("div");
		gridBody.className = "card-body p-0";
		var table = document.createElement("table");
		table.className = "table table-sm mb-0 align-middle table-fixed";
		var thead = document.createElement("thead");
		thead.className = "table-light";
		var trh = document.createElement("tr");
		var wdays = weekdayNames();
		for (var i = 0; i < wdays.length; i++) {
			var th = document.createElement("th");
			th.textContent = wdays[i];
			trh.appendChild(th);
		}
		thead.appendChild(trh);
		var tbody = document.createElement("tbody");
		table.appendChild(thead);
		table.appendChild(tbody);
		gridBody.appendChild(table);
		gridCard.appendChild(gridHead);
		gridCard.appendChild(gridBody);
		colGrid.appendChild(gridCard);

		// Colonne droite
		var colRight = document.createElement("div");
		colRight.className = "col-lg-4";

		// Évènement
		var editCard = document.createElement("div");
		editCard.className = "card";
		var editHead = document.createElement("div");
		editHead.className = "card-header";
		editHead.textContent = "Évènement";
		var editBody = document.createElement("div");
		editBody.className = "card-body";
		var form = document.createElement("form");
		form.id = "cal-form";

		function input(label, type) {
			var g = document.createElement("div");
			g.className = "mb-2";
			var l = document.createElement("label");
			l.className = "form-label";
			l.textContent = label;
			var i = document.createElement("input");
			i.type = type || "text";
			i.className = "form-control";
			g.appendChild(l);
			g.appendChild(i);
			return { group: g, input: i };
		}
		function textarea(label) {
			var g = document.createElement("div");
			g.className = "mb-2";
			var l = document.createElement("label");
			l.className = "form-label";
			l.textContent = label;
			var t = document.createElement("textarea");
			t.className = "form-control";
			t.rows = 3;
			g.appendChild(l);
			g.appendChild(t);
			return { group: g, input: t };
		}

		var fDate = input("Date", "date"),
			fStart = input("Début (HH:MM)", "time"),
			fEnd = input("Fin (HH:MM)", "time");
		var fTitle = input("Objet", "text"),
			fPeople = textarea("Personnes présentes (séparées par des virgules)"),
			fContent = textarea("Contenu / Notes");
		var fSubWrap = document.createElement("div");
		fSubWrap.className = "mb-2";
		var fSubChk = document.createElement("input");
		fSubChk.type = "checkbox";
		fSubChk.className = "form-check-input me-2";
		var fSubLab = document.createElement("label");
		fSubLab.className = "form-check-label me-2";
		fSubLab.textContent = "Créer des sous-tâches";
		var fSubN = document.createElement("input");
		fSubN.type = "number";
		fSubN.min = "1";
		fSubN.value = "3";
		fSubN.className = "form-control d-inline-block";
		fSubN.style.width = "90px";
		fSubWrap.appendChild(fSubChk);
		fSubWrap.appendChild(fSubLab);
		fSubWrap.appendChild(fSubN);

		var fHiddenId = document.createElement("input");
		fHiddenId.type = "hidden";
		var btnRow = document.createElement("div");
		btnRow.className = "d-flex gap-2 mt-2";
		var btnSave = document.createElement("button");
		btnSave.type = "submit";
		btnSave.className = "btn btn-primary";
		btnSave.textContent = "Enregistrer";
		var btnDelete = document.createElement("button");
		btnDelete.type = "button";
		btnDelete.className = "btn btn-outline-danger ms-auto";
		btnDelete.textContent = "Supprimer";

		// Planification
		var planCard = document.createElement("div");
		planCard.className = "card mt-3";
		var planHead = document.createElement("div");
		planHead.className = "card-header";
		planHead.textContent = "Suggestions de planification";
		var planBody = document.createElement("div");
		planBody.className = "card-body";
		var help = document.createElement("p");
		help.className = "text-muted small";
		help.textContent = "Insérer entre deux évènements, scinder, ou résoudre un chevauchement.";
		var selA = document.createElement("select");
		selA.className = "form-select mb-2";
		var selB = document.createElement("select");
		selB.className = "form-select mb-2";
		var btnBetween = document.createElement("button");
		btnBetween.type = "button";
		btnBetween.className = "btn btn-outline-secondary me-2";
		btnBetween.textContent = "Placer entre A et B";
		var btnResolve = document.createElement("button");
		btnResolve.type = "button";
		btnResolve.className = "btn btn-outline-secondary me-2";
		btnResolve.textContent = "Résoudre chevauchement";
		var btnSub = document.createElement("button");
		btnSub.type = "button";
		btnSub.className = "btn btn-outline-secondary";
		btnSub.textContent = "Créer n sous-évènements";

		planBody.appendChild(help);
		planBody.appendChild(selA);
		planBody.appendChild(selB);
		planBody.appendChild(btnBetween);
		planBody.appendChild(btnResolve);
		planBody.appendChild(btnSub);
		planCard.appendChild(planHead);
		planCard.appendChild(planBody);

		form.appendChild(fDate.group);
		form.appendChild(fStart.group);
		form.appendChild(fEnd.group);
		form.appendChild(fTitle.group);
		form.appendChild(fPeople.group);
		form.appendChild(fContent.group);
		form.appendChild(fSubWrap);
		form.appendChild(fHiddenId);
		btnRow.appendChild(btnSave);
		btnRow.appendChild(btnDelete);
		form.appendChild(btnRow);
		editBody.appendChild(form);
		editBody.appendChild(planCard);
		editCard.appendChild(editHead);
		editCard.appendChild(editBody);

		// Tâches
		var taskCard = document.createElement("div");
		taskCard.className = "card mt-3";
		var taskHead = document.createElement("div");
		taskHead.className = "card-header";
		taskHead.textContent = "Tâches";
		var taskBody = document.createElement("div");
		taskBody.className = "card-body";
		var newRow = document.createElement("div");
		newRow.className = "input-group mb-2";
		var inpNewTask = document.createElement("input");
		inpNewTask.type = "text";
		inpNewTask.className = "form-control";
		inpNewTask.placeholder = "Nouvelle tâche…";
		var btnAddTask = document.createElement("button");
		btnAddTask.className = "btn btn-outline-primary";
		btnAddTask.type = "button";
		btnAddTask.textContent = "Ajouter";
		newRow.appendChild(inpNewTask);
		newRow.appendChild(btnAddTask);
		var taskList = document.createElement("div");
		taskList.id = "cal-task-list";
		taskList.className = "d-flex flex-column gap-2";
		taskBody.appendChild(newRow);
		taskBody.appendChild(taskList);
		taskCard.appendChild(taskHead);
		taskCard.appendChild(taskBody);

		colRight.appendChild(editCard);
		colRight.appendChild(taskCard);

		row.appendChild(colGrid);
		row.appendChild(colRight);
		mount.appendChild(row);

		function renderMonth(ctx) {
			var label = new Date(ctx.y, ctx.m, 1).toLocaleDateString("fr-FR", { month: "long", year: "numeric" });
			title.textContent = ucFirstFr(label); // Mois avec première lettre en majuscule

			tbody.innerHTML = "";
			var first = new Date(ctx.y, ctx.m, 1);
			var jsDay = first.getDay();
			if (jsDay === 0) jsDay = 7;
			var leading = jsDay - 1;
			var days = new Date(ctx.y, ctx.m + 1, 0).getDate();
			var cells = leading + days,
				rows = Math.ceil(cells / 7);
			var d = 1;
			for (var r = 0; r < rows; r++) {
				var tr = document.createElement("tr");
				for (var c = 0; c < 7; c++) {
					var td = document.createElement("td");
					td.style.verticalAlign = "top";
					td.className = "align-top";
					if (r === 0 && c < leading) {
						td.innerHTML = "&nbsp;";
					} else if (d <= days) {
						(function (day) {
							var head = document.createElement("div");
							head.className = "d-flex justify-content-between align-items-start";
							var strong = document.createElement("strong");
							strong.textContent = String(day);
							var btnAdd = document.createElement("button");
							btnAdd.type = "button";
							btnAdd.className = "btn btn-sm btn-outline-primary";
							btnAdd.textContent = "+";
							head.appendChild(strong);
							head.appendChild(btnAdd);
							td.appendChild(head);

							var list = document.createElement("div");
							list.className = "mt-1 d-flex flex-column gap-1";
							var items = window.CalendrierModele.listEventsOnDay(ctx.profile, ctx.y, ctx.m, day);
							for (var i2 = 0; i2 < items.length; i2++) {
								var e = items[i2],
									sdt = new Date(e.startISO),
									edt = new Date(e.endISO);
								var b = document.createElement("button");
								b.type = "button";
								b.className = "btn btn-sm btn-light text-start";
								b.setAttribute("data-id", e.id);
								b.innerHTML = '<span class="badge text-bg-secondary me-1">' + formatTime(sdt) + "-" + formatTime(edt) + "</span>" + escapeHtml(e.title || "(sans objet)");
								list.appendChild(b);
							}
							td.appendChild(list);

							btnAdd.addEventListener("click", function () {
								fHiddenId.value = "";
								var base = new Date(ctx.y, ctx.m, day);
								var iso = base.toISOString().slice(0, 10);
								fDate.input.value = iso;
								fStart.input.value = "09:00";
								fEnd.input.value = "10:00";
								fTitle.input.value = "";
								fPeople.input.value = "";
								fContent.input.value = "";
							});
							list.addEventListener("click", function (ev) {
								var b = ev.target.closest("button[data-id]");
								if (!b) return;
								var id = b.getAttribute("data-id");
								var evts = ctx.profile.events;
								for (var j = 0; j < evts.length; j++)
									if (evts[j].id === id) {
										var e2 = evts[j],
											s = new Date(e2.startISO),
											en = new Date(e2.endISO);
										fHiddenId.value = e2.id;
										fDate.input.value = e2.startISO.slice(0, 10);
										fStart.input.value = pad2(s.getHours()) + ":" + pad2(s.getMinutes());
										fEnd.input.value = pad2(en.getHours()) + ":" + pad2(en.getMinutes());
										fTitle.input.value = e2.title || "";
										fPeople.input.value = e2.attendeesCsv || "";
										fContent.input.value = e2.content || "";
										break;
									}
							});
						})(d);
						d++;
					} else {
						td.innerHTML = "&nbsp;";
					}
					tr.appendChild(td);
				}
				tbody.appendChild(tr);
			}
		}

		function renderTasks(profile) {
			var taskList = document.getElementById("cal-task-list");
			if (!taskList) return;
			taskList.innerHTML = "";

			for (var i = 0; i < profile.tasks.length; i++) {
				var t = profile.tasks[i];

				var row = document.createElement("div");
				row.className = "border rounded p-2";
				row.setAttribute("data-task-id", t.id);

				// Ligne du haut : coche + titre + supprimer
				var top = document.createElement("div");
				top.className = "d-flex align-items-center gap-2";

				var chk = document.createElement("input");
				chk.type = "checkbox";
				chk.className = "form-check-input cal-task-done";
				chk.checked = !!t.done;

				var titleInp = document.createElement("input");
				titleInp.type = "text";
				titleInp.className = "form-control form-control-sm cal-task-title";
				titleInp.value = t.title;

				var btnDel = document.createElement("button");
				btnDel.type = "button";
				btnDel.className = "btn btn-sm btn-outline-danger cal-task-del ms-auto";
				btnDel.textContent = "Supprimer";

				top.appendChild(chk);
				top.appendChild(titleInp);
				top.appendChild(btnDel);

				// --- Commentaires ---
				var cWrap = document.createElement("div");
				cWrap.className = "mt-2";

				var cTitle = document.createElement("div");
				cTitle.className = "fw-semibold mb-1";
				cTitle.textContent = "Commentaires";

				var cList = document.createElement("div");
				cList.className = "d-flex flex-column gap-1";

				for (var j = 0; j < t.comments.length; j++) {
					var c = t.comments[j];

					var line = document.createElement("div");
					line.className = "d-flex align-items-start gap-2";
					line.setAttribute("data-cmt-id", c.id);

					var txt = document.createElement("div");
					txt.className = "flex-grow-1";
					var meta = new Date(c.createdISO).toLocaleString("fr-FR", { hour: "2-digit", minute: "2-digit", day: "2-digit", month: "2-digit", year: "numeric" });
					var upd = c.updatedISO
						? " (modifié " + new Date(c.updatedISO).toLocaleString("fr-FR", { hour: "2-digit", minute: "2-digit", day: "2-digit", month: "2-digit", year: "numeric" }) + ")"
						: "";
					txt.innerHTML = "<div>" + escapeHtml(c.text) + '</div><small class="text-muted">' + meta + upd + "</small>";

					var btnEdit = document.createElement("button");
					btnEdit.type = "button";
					btnEdit.className = "btn btn-sm btn-outline-secondary cal-cmt-edit";
					btnEdit.textContent = "Modifier";

					var btnDelC = document.createElement("button");
					btnDelC.type = "button";
					btnDelC.className = "btn btn-sm btn-outline-danger cal-cmt-del";
					btnDelC.textContent = "Supprimer";

					line.appendChild(txt);
					line.appendChild(btnEdit);
					line.appendChild(btnDelC);
					cList.appendChild(line);
				}

				// Ajout d’un commentaire
				var addRow = document.createElement("div");
				addRow.className = "input-group input-group-sm mt-1";

				var inp = document.createElement("input");
				inp.type = "text";
				inp.className = "form-control cal-cmt-text";
				inp.placeholder = "Nouveau commentaire…";

				var btnAdd = document.createElement("button");
				btnAdd.className = "btn btn-outline-primary cal-cmt-add";
				btnAdd.type = "button";
				btnAdd.textContent = "Ajouter";

				addRow.appendChild(inp);
				addRow.appendChild(btnAdd);

				cWrap.appendChild(cTitle);
				cWrap.appendChild(cList);
				cWrap.appendChild(addRow);

				row.appendChild(top);
				row.appendChild(cWrap);
				taskList.appendChild(row);
			}

			function escapeHtml(s) {
				return String(s).replace(/[&<>"']/g, function (m) {
					return { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[m];
				});
			}
		}

		function escapeHtml(s) {
			return String(s).replace(/[&<>"']/g, function (m) {
				return { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[m];
			});
		}

		return {
			mount: mount,
			profileSelect: selP,
			btnNewProfile: btnNewP,
			btnRenameProfile: btnRenP,
			btnDeleteProfile: btnDelP,
			btnPrev: btnPrev,
			btnNext: btnNext,
			btnToday: btnToday,
			renderMonth: renderMonth,
			renderTasks: renderTasks,
			getForm: function () {
				return {
					id: fHiddenId,
					date: fDate.input,
					start: fStart.input,
					end: fEnd.input,
					title: fTitle.input,
					people: fPeople.input,
					content: fContent.input,
					subChk: fSubChk,
					subN: fSubN,
				};
			},
			planningControls: { selA: selA, selB: selB, btnBetween: btnBetween, btnResolve: btnResolve, btnSubEvents: btnSub },
			updateEventChoices: function (events) {
				function fill(sel) {
					sel.innerHTML = "";
					var opt0 = document.createElement("option");
					opt0.value = "";
					opt0.textContent = "— choisir —";
					sel.appendChild(opt0);
					for (var i = 0; i < events.length; i++) {
						var e = events[i],
							dt = new Date(e.startISO);
						var lab = dt.toLocaleDateString("fr-FR") + " " + dt.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" }) + " — " + (e.title || "(sans objet)");
						var op = document.createElement("option");
						op.value = e.id;
						op.textContent = lab;
						sel.appendChild(op);
					}
				}
				fill(selA);
				fill(selB);
			},
			onSaveDelete: function (saveHandler, deleteHandler) {
				form.addEventListener("submit", function (e) {
					e.preventDefault();
					saveHandler();
				});
				btnDelete.addEventListener("click", function () {
					deleteHandler();
				});
			},
			tasksUI: { list: taskList, addBtn: btnAddTask, newInput: inpNewTask },
		};
	}

	window.CalendrierView = { createUI: createUI };
})(window, document);

# ./javascript/calendrier/calendrier_view.js

# ./javascript/covoiturage/covoiturage_controller.js
/* convoiturage_controller.js — Contrôleur */
(function (window) {
	"use strict";

	var Modele = window.ConvoiturageModele;
	var View = window.ConvoiturageView;

	// API publique
	window.initConvoiturage = function initConvoiturage(opts) {
		if (!opts || !opts.mount) throw new Error("initConvoiturage: {mount} requis.");

		var ui = View.createUI({ mount: opts.mount });

		// bornes de l'index d'arrêt saisi par l'utilisateur (1 = départ, N = arrivée)
		function refreshStopMax() {
			var stops = ui.collectStops(); // [ "Origine", ...escales..., "Destination" ]
			ui.groupsTbl.setMaxFor("stop", Math.max(1, stops.length)); // 1..N (N = nb arrêts totaux)
			ui.updateNLabels(stops.length); // maj "N" -> nombre contextuel
		}

		// Handlers
		ui.btnAddStop.button.addEventListener("click", function () {
			ui.stopsList.add({ label: "Nouvelle escale" });
			refreshStopMax();
		});

		// Si l'utilisateur modifie/supprime une escale via l'UI interne du listEditor
		ui.stopsHost.addEventListener("input", refreshStopMax);
		ui.stopsHost.addEventListener("change", refreshStopMax);
		ui.stopsHost.addEventListener("click", function () {
			// laisse le DOM se mettre à jour puis recalcule
			setTimeout(refreshStopMax, 0);
		});

		ui.btnAddCar.button.addEventListener("click", function () {
			ui.carsList.add({ capacity: 4, name: "" });
		});

		ui.cGroupCount.input.addEventListener("change", function () {
			ui.groupsTbl.setRowCount(Math.max(1, parseInt(ui.cGroupCount.input.value, 10) || 1));
			ui.groupsTbl.rerollRandoms();
		});

		ui.btnReg.button.addEventListener("click", function () {
			ui.groupsTbl.rerollRandoms();
		});

		ui.btnCompute.addEventListener("click", function () {
			var raw = ui.collectState();
			var check = Modele.validateState(raw);
			if (!check.ok) {
				window.GestionUI.alert(ui.spanAlert, "danger", check.message);
				ui.results.innerHTML = "";
				return;
			}
			var stateWithPeople = Modele.attachPeopleToGroups(raw);
			var itemsWrap = Modele.partitionGroups(stateWithPeople);
			var plan = Modele.assignItemsToTrips(itemsWrap.items, stateWithPeople);
			View.renderPlan(ui.results, plan, stateWithPeople);
			window.GestionUI.alert(ui.spanAlert, "success", "Plan généré.");
		});

		// Init bornes
		refreshStopMax();
	};
})(window);

# ./javascript/covoiturage/covoiturage_controller.js

# ./javascript/covoiturage/covoiturage_modele.js
/* convoiturage_modele.js — Modèle */
(function (window) {
	"use strict";

	var NAME_POOL = window.NOMS_POOL || [];
	var nameCounter = 0;

	function nextPersonName() {
		var base = NAME_POOL[nameCounter % NAME_POOL.length] || "Personne " + (nameCounter + 1);
		var round = Math.floor(nameCounter / NAME_POOL.length);
		nameCounter++;
		return round === 0 ? base : base + " (" + (round + 1) + ")";
	}

	/* ====== validation ====== */
	function validateState(state) {
		if (!state.cars || !state.cars.length) return { ok: false, message: "Ajoutez au moins une voiture." };
		if (!state.stops || state.stops.length < 2) return { ok: false, message: "Définissez au minimum Origine et Destination." };
		var S = state.stops.length - 1;
		for (var i = 0; i < state.groups.length; i++) {
			var st = parseInt(state.groups[i].stop, 10);
			if (!(st >= 1 && st <= S)) return { ok: false, message: "Un groupe a un arrêt invalide (doit être entre 1 et " + S + ")." };
		}
		return { ok: true };
	}

	/* ====== people attach ====== */
	function attachPeopleToGroups(state) {
		nameCounter = 0;
		var groups = [],
			i,
			p;
		for (i = 0; i < state.groups.length; i++) {
			var g = state.groups[i],
				people = [];
			for (p = 0; p < g.size; p++) people.push({ name: nextPersonName(), stop: g.stop, groupId: g.id });
			groups.push({ id: g.id, size: g.size, stop: g.stop, people: people });
		}
		return { stops: state.stops, cars: state.cars, groups: groups };
	}

	/* ====== partition (éviter la séparation sauf contrainte capacité) ====== */
	function partitionGroups(state) {
		var items = [],
			i,
			c;
		var bestCap = 0;
		for (c = 0; c < state.cars.length; c++) if (state.cars[c].capacity > bestCap) bestCap = state.cars[c].capacity;

		for (i = 0; i < state.groups.length; i++) {
			var g = state.groups[i];
			if (g.size <= bestCap) {
				items.push({ groupId: g.id, partIndex: 1, parts: 1, size: g.size, stop: g.stop, people: g.people.slice(0) });
			} else {
				var parts = Math.ceil(g.size / bestCap),
					remaining = g.size,
					offset = 0,
					p,
					take,
					slice;
				for (p = 1; p <= parts; p++) {
					take = Math.min(bestCap, remaining);
					slice = g.people.slice(offset, offset + take);
					items.push({ groupId: g.id, partIndex: p, parts: parts, size: take, stop: g.stop, people: slice, forced: true });
					remaining -= take;
					offset += take;
				}
			}
		}
		// trier par arrêt le plus loin puis par taille décroissante
		items.sort(function (a, b) {
			return b.stop - a.stop || b.size - a.size;
		});
		return { items: items };
	}

	/* ====== assignation en trajets (min allers-retours puis compacité) ====== */
	function assignItemsToTrips(items, state) {
		var openTrips = [],
			trips = [],
			tCounter = 0;
		var tripsPerCar = {},
			i,
			c;

		for (c = 0; c < state.cars.length; c++) tripsPerCar[state.cars[c].id] = 0;

		for (i = 0; i < items.length; i++) {
			var it = items[i],
				best = null,
				bestWaste = Infinity,
				ot,
				t;

			// Essayer de remplir un trajet ouvert
			for (ot = 0; ot < openTrips.length; ot++) {
				t = openTrips[ot];
				if (t.capLeft >= it.size) {
					var waste = t.capLeft - it.size;
					if (waste < bestWaste) {
						bestWaste = waste;
						best = t;
					}
				}
			}

			var chosen = best;
			if (!chosen) {
				// ouvrir un nouveau trajet sur la plus grande capacité disponible (ou la moins chargée ex æquo)
				var chosenCar = null;
				for (c = 0; c < state.cars.length; c++) {
					var car = state.cars[c];
					if (!chosenCar) chosenCar = car;
					else if (car.capacity > chosenCar.capacity) chosenCar = car;
					else if (car.capacity === chosenCar.capacity && (tripsPerCar[car.id] || 0) < (tripsPerCar[chosenCar.id] || 0)) chosenCar = car;
				}
				chosen = { id: ++tCounter, carId: chosenCar.id, capLeft: chosenCar.capacity, maxCap: chosenCar.capacity, stops: [], items: [] };
				openTrips.push(chosen);
				tripsPerCar[chosenCar.id] = (tripsPerCar[chosenCar.id] || 0) + 1;
			}

			chosen.items.push(it);
			chosen.capLeft -= it.size;
			addStopUnique(chosen.stops, it.stop);

			if (chosen.capLeft === 0) closeTrip(chosen);
		}

		// fermer les trajets restants
		for (var k = openTrips.length - 1; k >= 0; k--) closeTrip(openTrips[k]);

		function closeTrip(t) {
			// Les arrêts se font dans l’ordre croissant (du plus proche au plus lointain), Origine implicite (0)
			t.stops.sort(function (a, b) {
				return a - b;
			});
			trips.push({ id: t.id, carId: t.carId, capacity: t.maxCap, stops: t.stops.slice(0), items: t.items.slice(0) });
			var idx = indexOfTrip(openTrips, t);
			if (idx >= 0) openTrips.splice(idx, 1);
		}

		// ordre d’affichage : par voiture puis par arrêt max desservi
		trips.sort(function (a, b) {
			var d = a.carId - b.carId;
			return d !== 0 ? d : maxOfArray(b.stops) - maxOfArray(a.stops);
		});
		return trips;
	}

	/* ====== helpers ====== */
	function addStopUnique(stops, s) {
		for (var i = 0; i < stops.length; i++) if (stops[i] === s) return;
		stops.push(s);
	}
	function indexOfTrip(arr, t) {
		for (var i = 0; i < arr.length; i++) if (arr[i] === t) return i;
		return -1;
	}
	function maxOfArray(a) {
		if (!a.length) return -Infinity;
		var m = a[0];
		for (var i = 1; i < a.length; i++) if (a[i] > m) m = a[i];
		return m;
	}

	window.ConvoiturageModele = {
		validateState: validateState,
		attachPeopleToGroups: attachPeopleToGroups,
		partitionGroups: partitionGroups,
		assignItemsToTrips: assignItemsToTrips,
	};
})(window);

# ./javascript/covoiturage/covoiturage_modele.js

# ./javascript/covoiturage/covoiturage_view.js
/* convoiturage_view.js — Vue */
(function (window, document) {
	"use strict";

	function createUI(opts) {
		if (!opts || !opts.mount) throw new Error("ConvoiturageView.createUI: {mount} requis.");
		var mount = opts.mount;

		// Barre de paramètres générales
		var rowTop = document.createElement("div");
		rowTop.className = "row g-3 align-items-end mb-3";
		var cOrigin = colControl("Provenance", "text", "conv-origin", "Origine");
		var cDest = colControl("Destination", "text", "conv-dest", "Destination");
		var cStopCnt = colControl("Nombre d'escales (via +)", "number", "conv-stopCount", 0, { min: 0, readonly: true });
		rowTop.appendChild(cOrigin.col);
		rowTop.appendChild(cDest.col);
		rowTop.appendChild(cStopCnt.col);
		mount.appendChild(rowTop);

		// Escales (entre Origine et Destination)
		var stopsHost = document.createElement("div");
		mount.appendChild(stopsHost);
		var stopsList = window.GestionUI.listEditor(stopsHost, {
			title: "Escale",
			// 1 SEUL bouton : on supprime le bouton interne du listEditor
			addLabel: null,
			fields: [{ key: "label", label: "Nom de l'escale", type: "text", value: "Escale" }],
			initial: [],
			idKey: "id",
		});
		var btnAddStop = buttonControl("Ajouter une escale", "conv-btnAddStop", "btn btn-outline-primary mb-3");
		stopsHost.appendChild(btnAddStop.col);

		// Titre dynamique des groupes (on gère nous-mêmes le libellé avec N)
		var groupsTitle = document.createElement("h5");
		groupsTitle.id = "conv-groups-title";
		groupsTitle.className = "mt-3";
		mount.appendChild(groupsTitle);

		// Voitures
		var carsHost = document.createElement("div");
		mount.appendChild(carsHost);
		var carsList = window.GestionUI.listEditor(carsHost, {
			title: "Voiture",
			// 1) Supprime le bouton interne bleu -> un seul bouton (le nôtre)
			addLabel: null,
			fields: [
				{ key: "name", label: "Nom (optionnel)", type: "text", value: "" },
				{ key: "capacity", label: "Places", type: "number", min: 1, value: 4 },
			],
			initial: [{ name: "", capacity: 4 }],
			idKey: "id",
		});
		var btnAddCar = buttonControl("Ajouter une voiture", "conv-btnAddCar", "btn btn-outline-secondary mb-3");
		carsHost.appendChild(btnAddCar.col);

		// Helpers N dynamiques
		function countStopsTotal() {
			// N = Origine + escales + Destination
			var escalesCount = (stopsList.getData() || []).length;
			return 2 + escalesCount;
		}
		function mkStopLabel(N) {
			return "Arrêt (1 = départ, " + N + " = arrivée)";
		}

		// Groupes
		var rowMid = document.createElement("div");
		rowMid.className = "row g-3 align-items-end mb-3";
		var cGroupCnt = colControl("Nombre de groupes", "number", "conv-groupCount", 1, { min: 1 });
		var btnReg = buttonControl("Régénérer les groupes", "conv-btnRegenerateGroups", "btn btn-outline-secondary");
		rowMid.appendChild(cGroupCnt.col);
		rowMid.appendChild(btnReg.col);
		mount.appendChild(rowMid);

		var groupsHost = document.createElement("div");
		mount.appendChild(groupsHost);
		// libellés initiaux avec N courant
		var N0 = countStopsTotal();
		groupsTitle.textContent = "Groupes (" + mkStopLabel(N0) + ")";
		var groupsTbl = window.GestionUI.tableEditor(groupsHost, {
			title: "", // on gère notre titre à part (groupsTitle)
			rowLabel: "Groupe",
			initialRows: 1,
			columns: [
				// 2) Taille non bornée à 4
				{ key: "size", label: "Taille (personnes)", type: "number", min: 1, value: 1, defaultRandom: true },
				// 2) & 3) Libellé d'arrêt dynamique
				{ key: "stop", label: mkStopLabel(N0), type: "number", min: 1, value: 1, defaultRandom: true },
			],
			randomizeRow: function (col) {
				if (col.key === "size") return window.random_int(col.min || 1, col.max || 4); // random par défaut
				if (col.key === "stop") return 1; // max dynamique via setMaxFor côté contrôleur
				return "";
			},
		});

		// Actions & résultats
		var actions = document.createElement("div");
		actions.className = "sticky-actions border-top";
		var btnCompute = document.createElement("button");
		btnCompute.className = "btn btn-lg btn-primary";
		btnCompute.textContent = "Générer le plan";
		var spanAlert = document.createElement("span");
		spanAlert.id = "conv-computeAlert";
		spanAlert.className = "ms-3";
		actions.appendChild(btnCompute);
		actions.appendChild(spanAlert);
		mount.appendChild(actions);

		var results = document.createElement("div");
		results.id = "conv-results";
		results.className = "mt-4";
		mount.appendChild(results);

		function collectStops() {
			var origin = cOrigin.input.value || "Origine";
			var dest = cDest.input.value || "Destination";
			var escales = stopsList.getData().map(function (e) {
				return String(e.label || "Escale");
			});
			// compteur visuel (lecture seule) : nombre d'escales uniquement
			cStopCnt.input.value = String(escales.length);
			// Index humain: 1..N avec N = list.length (1=Origine, N=Destination)
			var list = [origin].concat(escales).concat([dest]);
			return list;
		}

		function collectState() {
			var stops = collectStops();
			var cars = carsList.getData().map(function (c) {
				return { id: c.id, capacity: Math.max(1, Math.floor(Number(c.capacity) || 1)), name: c.name || "Voiture #" + c.id };
			});
			var groupsHuman = groupsTbl.getData().map(function (g) {
				return { id: g.id, size: Math.max(1, Math.floor(Number(g.size) || 1)), stop: Math.max(1, Math.floor(Number(g.stop) || 1)) };
			});

			// Conversion "1 = départ … N = arrivée" -> interne 1..S (S = nb arrêts après l'origine)
			var S = Math.max(1, stops.length - 1); // 1..S (S inclut Destination)
			var groups = [];
			for (var i = 0; i < groupsHuman.length; i++) {
				var h = groupsHuman[i].stop; // 1..N
				var converted = Math.max(1, Math.min(h - 1, S)); // 1..S  (h-1 : on retire l'origine)
				groups.push({ id: groupsHuman[i].id, size: groupsHuman[i].size, stop: converted });
			}

			return { stops: stops, cars: cars, groups: groups };
		}

		// Mise à jour dynamique de "N" partout (titre + en-tête de colonne)
		function updateNLabels(N) {
			groupsTitle.textContent = "Groupes (" + mkStopLabel(N) + ")";
			// met à jour l'en-tête de colonne "stop" dans le thead rendu par tableEditor
			var thead = groupsHost.querySelector("thead");
			if (thead) {
				var ths = thead.querySelectorAll("th");
				for (var i = 0; i < ths.length; i++) {
					var th = ths[i];
					if (th.textContent.indexOf("Arrêt (") !== -1) {
						th.textContent = mkStopLabel(N);
						break;
					}
				}
			}
		}

		return {
			// exposés
			mount: mount,
			stopsHost: stopsHost,
			cOrigin: cOrigin,
			cDest: cDest,
			cStopCount: cStopCnt,
			stopsList: stopsList,
			btnAddStop: btnAddStop,
			carsList: carsList,
			btnAddCar: btnAddCar,
			cGroupCount: cGroupCnt,
			btnReg: btnReg,
			groupsTbl: groupsTbl,
			btnCompute: btnCompute,
			spanAlert: spanAlert,
			results: results,
			collectStops: collectStops,
			collectState: collectState,
			updateNLabels: updateNLabels,
		};
	}

	function renderPlan(mount, trips, state) {
		var split = {},
			t,
			i;
		for (t = 0; t < trips.length; t++)
			for (i = 0; i < trips[t].items.length; i++) {
				var gid = trips[t].items[i].groupId;
				split[gid] = (split[gid] || 0) + 1;
			}
		var actuallySplit = 0;
		for (var g in split) if (split.hasOwnProperty(g) && split[g] > 1) actuallySplit++;

		var kpis =
			'<div class="row g-3 mb-3">' +
			' <div class="col-auto"><div class="badge text-bg-primary p-3">Allers-retours totaux : <strong>' +
			trips.length +
			"</strong></div></div>" +
			' <div class="col-auto"><div class="badge text-bg-secondary p-3">Groupes séparés : <strong>' +
			actuallySplit +
			"</strong></div></div>" +
			' <div class="col-auto"><div class="badge text-bg-light border p-3">Arrêts (hors origine) : <strong>' +
			(state.stops.length - 1) +
			"</strong></div></div>" +
			"</div>";

		var thead =
			'<thead class="table-light"><tr>' +
			'<th style="width:70px;">#</th><th style="width:110px;">Voiture</th><th style="width:110px;">Capacité</th>' +
			'<th>Groupes embarqués</th><th style="width:260px;">Parcours</th><th style="width:220px;">Remarques</th>' +
			"</tr></thead>";

		var rows = "";
		for (t = 0; t < trips.length; t++) {
			var trip = trips[t];
			var car = getById(state.cars, trip.carId);
			var groupsHtml = "";
			for (i = 0; i < trip.items.length; i++) {
				var it = trip.items[i];
				var stopName = state.stops[it.stop]; // interne: 1..S => affiche bon libellé
				var title = "G" + it.groupId + (it.parts > 1 ? " (part " + it.partIndex + "/" + it.parts + ")" : "") + " : " + it.size + "p → " + stopName;
				var names = [];
				if (it.people) for (var n = 0; n < it.people.length; n++) names.push(it.people[n].name);
				groupsHtml +=
					'<div class="mb-2"><div>' +
					escapeHtml(title) +
					"</div>" +
					"<details><summary>" +
					it.size +
					" personne(s)</summary><small>" +
					(names.length ? escapeHtml(names.join(", ")) : "—") +
					"</small></details></div>";
			}

			var pathTxt =
				"Origine → " +
				trip.stops
					.map(function (s) {
						return state.stops[s];
					})
					.join(" → ") +
				" → Origine";
			var hasSplit = trip.items.some(function (it) {
				return it.parts > 1;
			});
			var remarks = [];
			if (hasSplit) remarks.push('<span class="group-split">Séparation nécessaire</span>');
			if (!trip.stops.length) remarks.push("—");

			rows +=
				"<tr>" +
				"<td>" +
				(t + 1) +
				"</td>" +
				"<td>#" +
				car.id +
				(car.name ? " — " + escapeHtml(car.name) : "") +
				"</td>" +
				"<td>" +
				trip.capacity +
				" p</td>" +
				"<td>" +
				groupsHtml +
				"</td>" +
				"<td>" +
				pathTxt +
				"</td>" +
				"<td>" +
				(remarks.length ? remarks.join("<br>") : "—") +
				"</td>" +
				"</tr>";
		}

		mount.innerHTML =
			kpis +
			'<div class="card"><div class="card-header">Séquence optimale (heuristique)</div>' +
			'<div class="card-body p-0"><div class="table-responsive"><table class="table table-striped table-hover align-middle table-fixed mb-0">' +
			thead +
			"<tbody>" +
			(rows || '<tr><td colspan="6" class="text-center text-muted">Aucun trajet nécessaire</td></tr>') +
			"</tbody></table></div></div>" +
			'<div class="card-footer text-muted">Objectif : minimiser les allers-retours puis éviter les séparations. Les groupes ne sont séparés que si les capacités le rendent inévitables.</div>' +
			"</div>";
	}

	/* ========== helpers vue ========== */
	function colControl(label, type, id, val, attrs) {
		var col = document.createElement("div");
		col.className = "col-auto";
		var lab = document.createElement("label");
		lab.className = "form-label";
		lab.setAttribute("for", id);
		lab.textContent = label;
		var inp = document.createElement("input");
		inp.className = "form-control";
		inp.id = id;
		inp.type = type || "text";
		inp.value = val || "";
		if (attrs) for (var k in attrs) if (attrs.hasOwnProperty(k)) inp.setAttribute(k, attrs[k]);
		col.appendChild(lab);
		col.appendChild(inp);
		return { col: col, input: inp };
	}
	function buttonControl(text, id, klass) {
		var col = document.createElement("div");
		col.className = "col-auto";
		var btn = document.createElement("button");
		btn.className = klass || "btn btn-secondary";
		btn.id = id;
		btn.type = "button";
		btn.textContent = text;
		col.appendChild(btn);
		return { col: col, button: btn };
	}
	function getById(arr, id) {
		for (var i = 0; i < arr.length; i++) if (arr[i].id === id) return arr[i];
		return null;
	}
	function escapeHtml(s) {
		return String(s).replace(/[&<>"']/g, function (m) {
			return { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[m];
		});
	}

	window.ConvoiturageView = { createUI: createUI, renderPlan: renderPlan };
})(window, document);

# ./javascript/covoiturage/covoiturage_view.js

# ./utils/GestionUIJS.js
/* GestionUIJS.js — micro-outillage UI (ES5, 2014) */
(function (window, document) {
	"use strict";

	var GestionUI = {};

	/* ============ utilitaires DOM ============ */
	function el(tag, attrs) {
		var node = document.createElement(tag);
		if (attrs)
			for (var k in attrs)
				if (attrs.hasOwnProperty(k)) {
					if (k === "class") node.className = attrs[k];
					else if (k === "text") node.textContent = attrs[k];
					else node.setAttribute(k, attrs[k]);
				}
		return node;
	}
	function empty(node) {
		while (node.firstChild) node.removeChild(node.firstChild);
	}
	function on(node, evt, fn) {
		node.addEventListener(evt, fn);
	}
	function setAttrs(node, attrs) {
		for (var k in attrs)
			if (attrs.hasOwnProperty(k)) {
				if (k === "class") node.className = attrs[k];
				else node.setAttribute(k, attrs[k]);
			}
	}

	/* ============ alert badge ============ */
	GestionUI.alert = function (container, flavor, text) {
		container.innerHTML = '<span class="badge text-bg-' + flavor + '">' + escapeHtml(text) + "</span>";
	};

	/* ============ éditeur de liste (cartes) ============ */
	// options: { title, addLabel, fields: [{key,label,type,min,max}], checks:[{key,label,exclusiveWith}], initial:[], idKey }
	GestionUI.listEditor = function (mount, options) {
		var idKey = options.idKey || "id";
		var seq = 0;
		var items = [];
		var root = el("div");

		var list = el("div", { class: "d-flex flex-wrap gap-3 mb-3" });
		var addBtn = el("button", { class: "btn btn-outline-primary mb-3", type: "button" });
		addBtn.textContent = options.addLabel || "Ajouter";
		on(addBtn, "click", function () {
			addItem();
		});

		root.appendChild(addBtn);
		root.appendChild(list);
		mount.appendChild(root);

		function addItem(preset) {
			var data = {};
			for (var i = 0; i < options.fields.length; i++) {
				var f = options.fields[i];
				data[f.key] = typeof f.value === "number" || typeof f.value === "string" ? f.value : "";
			}
			if (options.checks) {
				for (var c = 0; c < options.checks.length; c++) {
					data[options.checks[c].key] = false;
				}
			}
			if (preset) for (var k in preset) if (preset.hasOwnProperty(k)) data[k] = preset[k];

			data[idKey] = ++seq;

			var card = el("div", { class: "card card-elevator", "data-id": String(data[idKey]) });
			var header = el("div", { class: "card-header d-flex justify-content-between align-items-center" });
			header.appendChild(el("strong", { text: (options.title || "Item") + " #" + data[idKey] }));
			var del = el("button", { class: "btn btn-sm btn-outline-danger", type: "button" });
			del.textContent = "Supprimer";
			on(del, "click", function () {
				list.removeChild(card);
				for (var i = items.length - 1; i >= 0; i--) if (items[i][idKey] === data[idKey]) items.splice(i, 1);
			});
			header.appendChild(del);

			var body = el("div", { class: "card-body" });
			var row = el("div", { class: "row g-3" });

			// champs
			for (var i2 = 0; i2 < options.fields.length; i2++) {
				var f2 = options.fields[i2];
				var col = el("div", { class: "col-4" });
				var lab = el("label", { class: "form-label", text: f2.label });
				var inp = el("input", { class: "form-control", "data-key": f2.key, type: f2.type || "text" });
				if (typeof f2.min !== "undefined") inp.setAttribute("min", f2.min);
				if (typeof f2.max !== "undefined") inp.setAttribute("max", f2.max);
				inp.value = data[f2.key];
				on(inp, "change", syncData);
				col.appendChild(lab);
				col.appendChild(inp);
				row.appendChild(col);
			}
			body.appendChild(row);

			// checks
			if (options.checks && options.checks.length) {
				var row2 = el("div", { class: "row mt-2" });
				var colc = el("div", { class: "col-12" });
				for (var j = 0; j < options.checks.length; j++) {
					var ck = options.checks[j];
					var wrap = el("div", { class: "form-check form-check-inline" });
					var inpCk = el("input", { class: "form-check-input", type: "checkbox", "data-ck": ck.key, id: ck.key + "-" + data[idKey] });
					var labCk = el("label", { class: "form-check-label" });
					labCk.setAttribute("for", ck.key + "-" + data[idKey]);
					labCk.textContent = ck.label;
					on(
						inpCk,
						"change",
						(function (ckLocal) {
							return function () {
								data[ckLocal.key] = !!this.checked;
								// exclusivité
								if (ckLocal.exclusiveWith && this.checked) {
									var other = card.querySelector('input[data-ck="' + ckLocal.exclusiveWith + '"]');
									if (other) {
										other.checked = false;
										data[ckLocal.exclusiveWith] = false;
									}
								}
							};
						})(ck)
					);
					wrap.appendChild(inpCk);
					wrap.appendChild(labCk);
					colc.appendChild(wrap);
				}
				row2.appendChild(colc);
				body.appendChild(row2);
			}

			card.appendChild(header);
			card.appendChild(body);
			list.appendChild(card);

			items.push(data);
			return data;

			function syncData() {
				var inputs = card.querySelectorAll("input[data-key]");
				for (var ii = 0; ii < inputs.length; ii++) {
					var k2 = inputs[ii].getAttribute("data-key");
					var type = inputs[ii].getAttribute("type");
					var v = inputs[ii].value;
					if (type === "number") data[k2] = Math.floor(Number(v) || 0);
					else data[k2] = v;
				}
			}
		}

		// init
		if (options.initial && options.initial.length) {
			for (var z = 0; z < options.initial.length; z++) addItem(options.initial[z]);
		}

		return {
			add: addItem,
			getData: function () {
				// relire les champs courants
				var cards = list.querySelectorAll(".card-elevator");
				for (var c = 0; c < cards.length; c++) {
					var id = parseInt(cards[c].getAttribute("data-id"), 10);
					var inputs = cards[c].querySelectorAll("input[data-key]");
					for (var ii = 0; ii < inputs.length; ii++) {
						var key = inputs[ii].getAttribute("data-key");
						var type = inputs[ii].getAttribute("type");
						var v = inputs[ii].value;
						for (var it = 0; it < items.length; it++)
							if (items[it][idKey] === id) {
								items[it][key] = type === "number" ? Math.floor(Number(v) || 0) : v;
							}
					}
					// checks
					var cks = cards[c].querySelectorAll("input[data-ck]");
					for (var jj = 0; jj < cks.length; jj++) {
						var kck = cks[jj].getAttribute("data-ck");
						for (var it2 = 0; it2 < items.length; it2++) if (items[it2][idKey] === id) items[it2][kck] = !!cks[jj].checked;
					}
				}
				return items.slice(0);
			},
			setMaxFor: function (key, maxVal) {
				var inputs = list.querySelectorAll('input[data-key="' + key + '"]');
				for (var i3 = 0; i3 < inputs.length; i3++) inputs[i3].setAttribute("max", maxVal);
			},
		};
	};

	/* ============ éditeur de tableau (lignes simples) ============ */
	// config: { rowLabel, columns:[{key,label,type,min,max}], initialRows, randomizeRow(fn)->row }
	GestionUI.tableEditor = function (mount, config) {
		var wrapper = el("div", { class: "card mb-3" });
		var head = el("div", { class: "card-header" });
		head.textContent = config.title || "Table";
		var body = el("div", { class: "card-body p-0" });
		var table = el("table", { class: "table table-sm mb-0 align-middle table-fixed" });
		var thead = el("thead", { class: "table-light" });
		var trh = el("tr");
		trh.appendChild(el("th", { style: "width:90px;", text: config.rowLabel || "Ligne" }));
		for (var c = 0; c < config.columns.length; c++) trh.appendChild(el("th", { text: config.columns[c].label }));
		thead.appendChild(trh);
		var tbody = el("tbody");

		table.appendChild(thead);
		table.appendChild(tbody);
		body.appendChild(el("div", { class: "table-responsive" })).appendChild(table);
		wrapper.appendChild(head);
		wrapper.appendChild(body);
		mount.appendChild(wrapper);

		function setRowCount(n) {
			n = Math.max(1, Math.floor(n || 1));
			empty(tbody);
			for (var i = 1; i <= n; i++) {
				var tr = el("tr");
				tr.appendChild(el("td", { class: "smallcaps", text: (config.rowLabel || "Ligne") + " " + i }));
				for (var j = 0; j < config.columns.length; j++) {
					var col = config.columns[j];
					var td = el("td");
					var inp = el("input", { class: "form-control form-control-sm", "data-col": col.key, type: col.type || "text" });
					if (typeof col.min !== "undefined") inp.setAttribute("min", col.min);
					if (typeof col.max !== "undefined") inp.setAttribute("max", col.max);
					// valeur par défaut
					if (config.randomizeRow && col.defaultRandom) {
						inp.value = config.randomizeRow(col);
					} else if (typeof col.value !== "undefined") {
						inp.value = col.value;
					}
					td.appendChild(inp);
					tr.appendChild(td);
				}
				tbody.appendChild(tr);
			}
		}

		function getData() {
			var rows = tbody.querySelectorAll("tr");
			var out = [];
			for (var r = 0; r < rows.length; r++) {
				var obj = { id: r + 1 };
				var inputs = rows[r].querySelectorAll("input[data-col]");
				for (var i = 0; i < inputs.length; i++) {
					var k = inputs[i].getAttribute("data-col");
					var type = inputs[i].getAttribute("type");
					var v = inputs[i].value;
					obj[k] = type === "number" ? Math.floor(Number(v) || 0) : v;
				}
				out.push(obj);
			}
			return out;
		}

		function setMaxFor(colKey, maxVal) {
			var inputs = tbody.querySelectorAll('input[data-col="' + colKey + '"]');
			for (var i = 0; i < inputs.length; i++) inputs[i].setAttribute("max", maxVal);
		}

		function rerollRandoms() {
			if (!config.randomizeRow) return;
			var rows = tbody.querySelectorAll("tr");
			for (var r = 0; r < rows.length; r++) {
				var inputs = rows[r].querySelectorAll("input[data-col]");
				for (var i = 0; i < inputs.length; i++) {
					var k = inputs[i].getAttribute("data-col");
					// seuls les colonnes avec defaultRandom = true
					for (var j = 0; j < config.columns.length; j++)
						if (config.columns[j].key === k && config.columns[j].defaultRandom) {
							inputs[i].value = config.randomizeRow(config.columns[j]);
						}
				}
			}
		}

		// init
		setRowCount(config.initialRows || 1);

		return {
			setRowCount: setRowCount,
			getData: getData,
			setMaxFor: setMaxFor,
			rerollRandoms: rerollRandoms,
		};
	};

	function escapeHtml(s) {
		return String(s).replace(/[&<>"']/g, function (m) {
			return { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[m];
		});
	}

	window.GestionUI = GestionUI;
})(window, document);

# ./utils/GestionUIJS.js

# ./utils/utils.js
function random_int(min, max) {
	min = Math.floor(Number(min) || 0);
	max = Math.floor(Number(max) || 0);
	if (min > max) {
		var tmp = min;
		min = max;
		max = tmp;
	}
	var r = min + Math.floor(Math.random() * (max - min + 1));
	if (r < min) r = min;
	if (r > max) r = max;
	return r;
}

# ./utils/utils.js


Liste des fichiers trouvés et concaténés :
./data/noms.js
./index.html
./javascript/ascenseur/ascenseur_controller.js
./javascript/ascenseur/ascenseur_modele.js
./javascript/ascenseur/ascenseur_view.js
./javascript/calendrier/calendrier_controller.js
./javascript/calendrier/calendrier_modele.js
./javascript/calendrier/calendrier_view.js
./javascript/covoiturage/covoiturage_controller.js
./javascript/covoiturage/covoiturage_modele.js
./javascript/covoiturage/covoiturage_view.js
./utils/GestionUIJS.js
./utils/utils.js
