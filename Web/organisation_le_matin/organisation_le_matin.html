<!doctype html>
<html lang="fr">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link rel="icon" type="image/x-icon" href="organisation_le_matin.ico">
	<title>Routine avant de partir — calculateur</title>
	<!-- Bootstrap 5 (CDN) -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<style>
		:root {
			--warm1: #FFB703;
			--warm2: #FB8500;
			--warm3: #FCA311;
			--gray1: #f8f9fa;
			--gray2: #e9ecef;
			--gray3: #ced4da;
			--text: #212529;
		}

		body {
			min-height: 100vh;
			color: var(--text);
			background: linear-gradient(180deg, #fff6d6 0%, #ffd89b 35%, #f9a43f 60%, #f28c28 100%);
			background-attachment: fixed;
		}

		.app-card {
			background: linear-gradient(180deg, rgba(255, 255, 255, .95), rgba(255, 255, 255, .92));
			border: 1px solid var(--gray3);
			box-shadow: 0 10px 30px rgba(0, 0, 0, .08);
			border-radius: 14px;
		}

		.badge-warm {
			background: linear-gradient(90deg, var(--warm1), var(--warm2));
		}

		.handle {
			cursor: grab;
			user-select: none;
			font-size: 1.25rem;
			line-height: 1;
			color: #6c757d;
			display: flex;
			align-items: center;
			justify-content: center;
			width: 2rem;
		}

		.handle:active {
			cursor: grabbing;
		}

		.step-item {
			background: var(--gray1);
			border: 1px solid var(--gray3);
			border-radius: 10px;
			padding: .5rem .5rem;
			display: flex;
			align-items: center;
			gap: .5rem;
		}

		.step-item.dragging {
			opacity: .6;
		}

		.step-item .minutes {
			width: 7rem;
		}

		.step-item .name {
			flex: 1 1 auto;
			min-width: 8rem;
		}

		.drop-marker {
			height: 10px;
			border-radius: 6px;
			background: linear-gradient(90deg, var(--warm2), var(--warm1));
			margin: .25rem 0;
			display: none;
		}

		.drop-marker.active {
			display: block;
		}

		.subtle {
			color: #6c757d;
		}

		.metric {
			background: var(--gray1);
			border: 1px dashed var(--gray3);
			border-radius: 10px;
			padding: .75rem 1rem;
		}

		.progress {
			height: .5rem;
		}

		.footer-links a {
			color: #495057;
			text-decoration: underline dotted;
		}

		.input-time {
			max-width: 11rem;
		}

		@media (max-width:576px) {
			.step-item {
				flex-wrap: wrap;
			}

			.step-item .minutes {
				width: 100%;
			}

			.step-item .name {
				width: 100%;
			}
		}

		/* Petits boutons dans les onglets */
		.tab-close {
			border: none;
			background: transparent;
			color: #6c757d;
			margin-left: .25rem;
			line-height: 1;
			padding: 0 .25rem;
		}

		.tab-close:hover {
			color: #dc3545;
		}
	</style>
</head>

<body>
	<main class="container py-4 py-md-5">
		<header class="mb-4 text-center">
			<h1 class="h3 fw-bold mb-1">Calculateur « Avant de partir »</h1>
			<p class="mb-0 subtle">Durées modifiables, ordre réorganisable par poignées, calculs en direct.</p>
		</header>

		<section class="app-card p-3 p-md-4">
			<!-- Onglets de profils -->
			<ul id="profileTabs" class="nav nav-tabs mb-3"></ul>
			<div class="d-flex flex-wrap gap-2 justify-content-end mb-3">
				<button id="newProfileBtn" class="btn btn-sm btn-outline-primary">Nouvel onglet</button>
				<button id="renameProfileBtn" class="btn btn-sm btn-outline-secondary">Renommer l’onglet</button>
				<button id="deleteProfileBtn" class="btn btn-sm btn-outline-danger">Supprimer l’onglet</button>
			</div>

			<div class="row g-3 align-items-end">
				<div class="col-12 col-md">
					<label for="departureTime" class="form-label fw-semibold">Heure de départ</label>
					<input id="departureTime" type="time" class="form-control input-time" step="60" />
				</div>
				<div class="col-12 col-md">
					<div class="metric">
						<div class="d-flex justify-content-between">
							<span class="fw-semibold">Départ dans</span>
							<span id="countdown" class="fw-bold"></span>
						</div>
						<div class="progress mt-2">
							<div id="countdownBar" class="progress-bar" role="progressbar" style="width:0%"></div>
						</div>
					</div>
				</div>
				<div class="col-12 col-md-auto text-md-end d-flex gap-2">
					<button id="resetBtn" class="btn btn-outline-secondary">Réinitialiser</button>
				</div>
			</div>

			<hr class="my-4">

			<div class="d-flex align-items-center justify-content-between mb-2">
				<h2 class="h5 mb-0">Étapes de la routine</h2>
				<span class="badge badge-warm text-dark">Glisser-déposer avec la poignée</span>
			</div>

			<ul id="steps" class="list-unstyled d-grid gap-2 mb-2"></ul>
			<div id="dropMarker" class="drop-marker"></div>
			<div class="d-grid mb-3">
				<button id="addBtn" class="btn btn-sm btn-outline-primary">Ajouter</button>
			</div>

			<!-- Intervalle entre Manger et Toilette 2 (pas une étape) -->
			<div class="row g-2 mb-4">
				<div class="col-12 col-md-6">
					<label class="form-label fw-semibold" for="intervalToilettes">
						Intervalle entre « Manger » et « Toilette 2 »
					</label>
					<div class="input-group input-group-sm" style="max-width:14rem">
						<input id="intervalToilettes" type="number" class="form-control" min="0" max="240" step="5"
							value="60" />
						<span class="input-group-text">min</span>
					</div>
					<div class="form-text">
						Pris en compte dans la durée totale <span id="intervalStatus" class="fw-semibold"></span>.
					</div>
				</div>
			</div>

			<div class="row g-3">
				<div class="col-12 col-lg-4">
					<div class="metric">
						<div class="fw-semibold">Durée totale</div>
						<div id="totalDuration" class="fs-5 fw-bold"></div>
						<div id="totalMinutes" class="subtle"></div>
					</div>
				</div>
				<div class="col-12 col-lg-4">
					<div class="metric">
						<div class="fw-semibold">Début au plus tard</div>
						<div id="latestStart" class="fs-5 fw-bold"></div>
						<div id="latestStartRel" class="subtle"></div>
					</div>
				</div>
				<div class="col-12 col-lg-4">
					<div class="metric">
						<div class="fw-semibold">Marge</div>
						<div id="slack" class="fs-5 fw-bold"></div>
						<div id="slackHint" class="subtle"></div>
					</div>
				</div>
			</div>
		</section>

		<footer class="text-center mt-4 subtle footer-links">
			<small>Astuce : cochez/décochez pour inclure une étape. « Ajouter » crée une nouvelle activité de 15 min.
				L’intervalle est ajouté seulement si « Manger » est avant « Toilette 2 ».</small>
		</footer>
	</main>

	<script>
		// ========================
		//   Constantes & défauts
		// ========================
		const STORAGE_NS = 'a_faire_avant_de_partir'; // namespace
		const PROFILE_DEFAULT_NAME = 'routine du matin';

		const DEFAULT_STEPS = [
			{id: "wake", label: "Se lever", minutes: 30, min: 0, max: 240, enabled: true},
			{id: "toilette1", label: "Toilette 1", minutes: 15, min: 0, max: 120, enabled: true},
			{id: "prep", label: "Mise en condition (coiffer / raser)", minutes: 15, min: 0, max: 120, enabled: true},
			{id: "eat", label: "Manger", minutes: 15, min: 0, max: 120, enabled: true},
			{id: "toilette2", label: "Toilette 2", minutes: 15, min: 0, max: 120, enabled: true},
			{id: "buffer", label: "Battement (s'habiller + vérifier fenêtres)", minutes: 10, min: 0, max: 120, enabled: true}
		];
		const DEFAULT_INTERVAL_TOILETTES = 60; // minutes

		// ========================
		//       État global
		// ========================
		const state = {
			profile: PROFILE_DEFAULT_NAME,
			steps: structuredClone(DEFAULT_STEPS),
			intervalToilettes: DEFAULT_INTERVAL_TOILETTES,
			drag: {id: null, placeholderIndex: -1},
			_intervalApplies: true
		};

		// ========================
		//         Sélecteurs
		// ========================
		const $profileTabs = document.getElementById('profileTabs');
		const $newProfileBtn = document.getElementById('newProfileBtn');
		const $renameProfileBtn = document.getElementById('renameProfileBtn');
		const $deleteProfileBtn = document.getElementById('deleteProfileBtn');

		const $steps = document.getElementById('steps');
		const $dropMarker = document.getElementById('dropMarker');
		const $departureTime = document.getElementById('departureTime');
		const $countdown = document.getElementById('countdown');
		const $countdownBar = document.getElementById('countdownBar');
		const $totalDuration = document.getElementById('totalDuration');
		const $totalMinutes = document.getElementById('totalMinutes');
		const $latestStart = document.getElementById('latestStart');
		const $latestStartRel = document.getElementById('latestStartRel');
		const $slack = document.getElementById('slack');
		const $slackHint = document.getElementById('slackHint');
		const $resetBtn = document.getElementById('resetBtn');
		const $intervalToilettes = document.getElementById('intervalToilettes');
		const $intervalStatus = document.getElementById('intervalStatus');
		const $addBtn = document.getElementById('addBtn');

		// ========================
		//        Utilitaires
		// ========================
		const pad = n => String(n).padStart(2, '0');
		const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
		const minutesToHm = total => {
			const sign = total < 0 ? '-' : '';
			const m = Math.abs(total), h = Math.floor(m / 60), mm = m % 60;
			return sign + (h ? `${h} h ${pad(mm)} min` : `${mm} min`);
		};
		const timeToMinutes = t => {if (!t) return 8 * 60 + 25; const [h, m] = t.split(':').map(Number); return h * 60 + m;};
		const minutesToTime = m => {m = ((m % 1440) + 1440) % 1440; const h = Math.floor(m / 60), mm = m % 60; return `${pad(h)}:${pad(mm)}`;};
		function nextDateForTime(hhmm) {
			const now = new Date(); const [h, m] = hhmm.split(':').map(Number);
			const d = new Date(now); d.setHours(h, m, 0, 0); if (d <= now) d.setDate(d.getDate() + 1); return d;
		}

		// ========================
		//        Stockage
		// ========================
		const manifestKey = () => `${STORAGE_NS}:manifest`;
		const profileKey = (name) => `${STORAGE_NS}:${name}`;

		function saveManifest(m) {
			try {localStorage.setItem(manifestKey(), JSON.stringify(m));} catch (_) { }
		}
		function loadManifest() {
			try {
				const raw = localStorage.getItem(manifestKey());
				if (raw) return JSON.parse(raw);
			} catch (_) { }
			// Migration éventuelle de l’ancien stockage mono-profil
			const legacy = localStorage.getItem(STORAGE_NS);
			if (legacy) {
				try {
					localStorage.setItem(profileKey(PROFILE_DEFAULT_NAME), legacy);
					localStorage.removeItem(STORAGE_NS);
				} catch (_) { }
			} else {
				// Si aucun profil, créer le défaut
				const data = defaultProfileData();
				try {localStorage.setItem(profileKey(PROFILE_DEFAULT_NAME), JSON.stringify(data));} catch (_) { }
			}
			const m = {active: PROFILE_DEFAULT_NAME, order: [PROFILE_DEFAULT_NAME]};
			saveManifest(m);
			return m;
		}
		function saveProfile(name, data) {
			try {localStorage.setItem(profileKey(name), JSON.stringify(data));} catch (_) { }
		}
		function loadProfile(name) {
			try {
				const raw = localStorage.getItem(profileKey(name));
				return raw ? JSON.parse(raw) : null;
			} catch (_) {return null;}
		}
		function deleteProfileFromStorage(name) {
			try {localStorage.removeItem(profileKey(name));} catch (_) { }
		}

		function defaultProfileData() {
			return {
				steps: structuredClone(DEFAULT_STEPS),
				intervalToilettes: DEFAULT_INTERVAL_TOILETTES,
				departureTime: '08:25'
			};
		}
		function currentProfileData() {
			return {
				steps: state.steps.map(s => ({
					id: s.id, label: s.label, minutes: Number(s.minutes) || 0,
					min: s.min ?? 0, max: s.max ?? 600, enabled: s.enabled !== false
				})),
				intervalToilettes: Number(state.intervalToilettes) || 0,
				departureTime: $departureTime.value || '08:25'
			};
		}

		// ========================
		//   Gestion des profils
		// ========================
		let manifest = loadManifest();

		function ensureUniqueName(base) {
			const clean = (base || '').trim() || 'Onglet';
			if (!manifest.order.includes(clean)) return clean;
			let n = 2;
			while (manifest.order.includes(`${clean} (${n})`)) n++;
			return `${clean} (${n})`;
		}
		function nextPreparationName() {
			const nums = manifest.order
				.map(n => n.match(/^Préparation\s+(\d+)$/i))
				.filter(Boolean).map(m => parseInt(m[1], 10));
			let i = 1; while (nums.includes(i)) i++;
			return `Préparation ${i}`;
		}

		function buildTabs() {
			$profileTabs.innerHTML = '';
			manifest.order.forEach(name => {
				const li = document.createElement('li'); li.className = 'nav-item';
				const btn = document.createElement('button');
				btn.type = 'button';
				btn.className = 'nav-link' + (name === state.profile ? ' active' : '');
				btn.textContent = name;
				btn.addEventListener('click', () => switchProfile(name));
				li.appendChild(btn);
				$profileTabs.appendChild(li);
			});
		}

		function switchProfile(name) {
			// Sauvegarder l’actuel avant de basculer
			saveState(); // écrit dans la clé du profil actif
			// Charger le nouveau
			const data = loadProfile(name) || defaultProfileData();
			applyProfileData(name, data);
			manifest.active = name;
			saveManifest(manifest);
			buildTabs();
			rebuildList();
			renderMetrics();
		}

		function applyProfileData(name, data) {
			state.profile = name;
			state.steps = Array.isArray(data.steps)
				? data.steps.map(s => ({
					id: s.id ?? `custom_${Date.now()}`, label: s.label ?? 'Activité à faire',
					minutes: Number(s.minutes) || 0, min: s.min ?? 0, max: s.max ?? 600,
					enabled: s.enabled !== false
				}))
				: structuredClone(DEFAULT_STEPS);
			state.intervalToilettes = (typeof data.intervalToilettes === 'number') ? data.intervalToilettes : DEFAULT_INTERVAL_TOILETTES;
			$intervalToilettes.value = state.intervalToilettes;
			$departureTime.value = data.departureTime || '08:25';
		}

		function createProfile() {
			const name = ensureUniqueName(nextPreparationName());
			const data = defaultProfileData();
			saveProfile(name, data);
			manifest.order.push(name);
			manifest.active = name;
			saveManifest(manifest);
			switchProfile(name);
		}

		function renameCurrentProfile() {
			const oldName = state.profile;
			const input = prompt('Nouveau nom de l’onglet :', oldName);
			if (input === null) return; // annulé
			const trimmed = input.trim();
			if (!trimmed) return;
			const newName = trimmed === oldName ? oldName : ensureUniqueName(trimmed);

			if (newName === oldName) {buildTabs(); return;}

			// Déplacer les données sous la nouvelle clé
			saveState(); // s’assurer que l’état est à jour
			const data = loadProfile(oldName) || currentProfileData();
			saveProfile(newName, data);
			deleteProfileFromStorage(oldName);

			// Mettre à jour le manifeste
			manifest.order = manifest.order.map(n => n === oldName ? newName : n);
			manifest.active = newName;
			saveManifest(manifest);

			// Appliquer et rerender
			applyProfileData(newName, data);
			buildTabs();
			rebuildList();
			renderMetrics();
		}

		function deleteCurrentProfile() {
			const name = state.profile;
			const ok = confirm(`Supprimer l’onglet « ${name} » ?\nCette action efface ses données locales.`);
			if (!ok) return;

			deleteProfileFromStorage(name);
			manifest.order = manifest.order.filter(n => n !== name);

			if (manifest.order.length === 0) {
				const def = PROFILE_DEFAULT_NAME;
				const data = defaultProfileData();
				saveProfile(def, data);
				manifest.order = [def];
				manifest.active = def;
				saveManifest(manifest);
				applyProfileData(def, data);
			} else {
				const next = manifest.order[0];
				manifest.active = next;
				saveManifest(manifest);
				const data = loadProfile(next) || defaultProfileData();
				applyProfileData(next, data);
			}

			buildTabs();
			rebuildList();
			renderMetrics();
		}

		// ========================
		//   Stockage (profil)
		// ========================
		function saveState() {
			const data = currentProfileData();
			saveProfile(state.profile, data);
		}
		function loadState() {
			const data = loadProfile(state.profile);
			if (!data) return false;
			applyProfileData(state.profile, data);
			return true;
		}

		// ========================
		//   Construction UI steps
		// ========================
		function buildStepItem(step) {
			const li = document.createElement('li'); li.className = 'step-item'; li.dataset.id = step.id;

			const handle = document.createElement('div');
			handle.className = 'handle'; handle.title = 'Glisser pour réordonner';
			handle.setAttribute('aria-label', 'Poignée de réorganisation');
			handle.textContent = '≡'; handle.setAttribute('draggable', 'true');

			const cb = document.createElement('input');
			cb.type = 'checkbox'; cb.className = 'form-check-input m-0'; cb.checked = step.enabled !== false;
			cb.title = 'Inclure cette étape dans le calcul';

			const nameWrap = document.createElement('div'); nameWrap.className = 'name';
			nameWrap.innerHTML = `<input type="text" class="form-control form-control-sm" value="${step.label}">`;
			const nameInput = nameWrap.querySelector('input');

			const minutesWrap = document.createElement('div'); minutesWrap.className = 'minutes';
			minutesWrap.innerHTML = `
        <div class="input-group input-group-sm">
          <input type="number" class="form-control" min="${step.min ?? 0}" max="${step.max ?? 600}" step="1" value="${step.minutes}" aria-label="Minutes pour ${step.label}">
          <span class="input-group-text">min</span>
        </div>`;
			const minutesInput = minutesWrap.querySelector('input');

			const delBtn = document.createElement('button');
			delBtn.className = 'btn btn-sm btn-outline-danger';
			delBtn.textContent = 'Supprimer';
			delBtn.title = 'Supprimer cette étape';

			li.append(handle, cb, nameWrap, minutesWrap, delBtn);

			cb.addEventListener('change', () => {step.enabled = cb.checked; renderMetrics();});
			nameInput.addEventListener('input', () => {step.label = nameInput.value || 'Activité'; minutesInput.setAttribute('aria-label', `Minutes pour ${step.label}`); saveState();});
			minutesInput.addEventListener('input', () => {
				const v = clamp(parseInt(minutesInput.value || '0', 10), step.min ?? 0, step.max ?? 600);
				minutesInput.value = v; step.minutes = v; renderMetrics();
			});
			delBtn.addEventListener('click', () => {
				const idx = state.steps.findIndex(s => s.id === step.id);
				if (idx !== -1) {state.steps.splice(idx, 1); rebuildList(); renderMetrics();}
			});

			handle.addEventListener('dragstart', (e) => {
				state.drag.id = step.id;
				li.classList.add('dragging');
				e.dataTransfer.effectAllowed = 'move';
				e.dataTransfer.setData('text/plain', step.id);
			});
			handle.addEventListener('dragend', () => {
				li.classList.remove('dragging');
				state.drag.id = null;
				$dropMarker.classList.remove('active');
			});

			return li;
		}

		function rebuildList() {
			$steps.innerHTML = '';
			for (const step of state.steps) {$steps.appendChild(buildStepItem(step));}
		}

		// --- DnD helpers
		const itemsWithoutDragging = () => [...$steps.querySelectorAll('.step-item:not(.dragging)')];
		function getDropIndexByY(y) {
			const els = itemsWithoutDragging();
			let closest = {offset: Number.NEGATIVE_INFINITY, element: null};
			for (const el of els) {
				const box = el.getBoundingClientRect();
				const offset = y - (box.top + box.height / 2);
				if (offset < 0 && offset > closest.offset) {closest = {offset, element: el};}
			}
			return closest.element ? els.indexOf(closest.element) : els.length;
		}
		function positionDropMarkerByIndex(idx) {
			const els = itemsWithoutDragging();
			$dropMarker.classList.add('active');
			if (idx >= 0 && idx < els.length) {els[idx].before($dropMarker);} else {$steps.appendChild($dropMarker);}
			$dropMarker.style.width = '100%';
		}

		// ========================
		//         Calculs
		// ========================
		function intervalApplies() {
			const idxEat = state.steps.findIndex(s => s.id === 'eat');
			const idxT2 = state.steps.findIndex(s => s.id === 'toilette2');
			const eatEnabled = idxEat !== -1 && (state.steps[idxEat].enabled !== false);
			const t2Enabled = idxT2 !== -1 && (state.steps[idxT2].enabled !== false);
			return eatEnabled && t2Enabled && idxEat < idxT2;
		}
		function totalMinutes() {
			const stepsSum = state.steps.reduce((s, st) => s + ((st.enabled !== false) ? (parseInt(st.minutes, 10) || 0) : 0), 0);
			const interval = parseInt(state.intervalToilettes, 10) || 0;
			const applies = intervalApplies();
			state._intervalApplies = applies;
			return stepsSum + (applies ? interval : 0);
		}

		// ========================
		//          Rendu
		// ========================
		function renderMetrics() {
			const total = totalMinutes();
			const depStr = $departureTime.value || '08:25';
			const dep = nextDateForTime(depStr);
			const now = new Date();

			$totalDuration.textContent = minutesToHm(total);
			$totalMinutes.textContent = `${total} minutes`;

			if (state._intervalApplies) {
				$intervalStatus.textContent = '(appliqué)';
				$intervalStatus.classList.remove('text-danger'); $intervalStatus.classList.add('text-success');
			} else {
				$intervalStatus.textContent = "(non appliqué car ordre/état ne le permet pas)";
				$intervalStatus.classList.remove('text-success'); $intervalStatus.classList.add('text-danger');
			}

			const depMinutes = timeToMinutes(depStr);
			const latestStartMinutes = depMinutes - total;
			$latestStart.textContent = minutesToTime(latestStartMinutes);

			const latestStartDate = new Date(dep);
			latestStartDate.setMinutes(latestStartDate.getMinutes() - total);
			$latestStartRel.textContent = relativeFromNow(latestStartDate);

			const minUntilDep = Math.round((dep - now) / 60000);
			const slackMin = minUntilDep - total;
			$slack.textContent = minutesToHm(slackMin);
			$slack.classList.toggle('text-success', slackMin >= 0);
			$slack.classList.toggle('text-danger', slackMin < 0);
			$slackHint.textContent = slackMin >= 0
				? "Temps disponible en plus si vous commencez maintenant."
				: "Retard si vous commencez maintenant (à rattraper).";

			renderCountdown(dep);
			saveState();
		}

		function renderCountdown(depDate) {
			const now = new Date(); let ms = depDate - now; if (ms < 0) ms = 0;
			const s = Math.floor(ms / 1000), h = Math.floor(s / 3600), m = Math.floor((s % 3600) / 60);
			$countdown.textContent = `${pad(h)}:${pad(m)}`;
			const startWindow = new Date(depDate); startWindow.setHours(startWindow.getHours() - 8);
			const totalWindow = depDate - startWindow, elapsed = now - startWindow;
			const pct = clamp(Math.round((elapsed / totalWindow) * 100), 0, 100);
			$countdownBar.style.width = pct + '%';
			$countdownBar.style.background = 'linear-gradient(90deg, var(--warm1), var(--warm2))';
		}

		function relativeFromNow(target) {
			const now = new Date(); const diffMin = Math.round((target - now) / 60000);
			if (diffMin > 0) return `dans ${minutesToHm(diffMin)}`;
			if (diffMin < 0) return `il y a ${minutesToHm(-diffMin)}`;
			return "maintenant";
		}

		function setDefaultDeparture() {$departureTime.value = '08:25';}

		// ========================
		//     Initialisation
		// ========================
		function init() {
			// Charger profil actif du manifeste
			state.profile = manifest.active || PROFILE_DEFAULT_NAME;
			if (!loadState()) { // si pas de données, créer défaut
				const data = defaultProfileData();
				saveProfile(state.profile, data);
				applyProfileData(state.profile, data);
			}

			buildTabs();
			rebuildList();
			renderMetrics();

			// DnD liste
			$steps.addEventListener('dragover', (e) => {
				if (!state.drag.id) return;
				e.preventDefault();
				const idx = getDropIndexByY(e.clientY);
				state.drag.placeholderIndex = idx;
				positionDropMarkerByIndex(idx);
			});
			$steps.addEventListener('drop', (e) => {
				if (!state.drag.id) return;
				e.preventDefault();
				const fromIdx = state.steps.findIndex(s => s.id === state.drag.id);
				let toIdx = state.drag.placeholderIndex;
				if (fromIdx === -1 || toIdx === -1) {$dropMarker.classList.remove('active'); return;}
				if (fromIdx < toIdx) toIdx--;
				const [moved] = state.steps.splice(fromIdx, 1);
				state.steps.splice(Math.max(0, Math.min(toIdx, state.steps.length)), 0, moved);
				rebuildList();
				renderMetrics();
				$dropMarker.classList.remove('active');
				state.drag.id = null;
			});

			// Inputs
			$departureTime.addEventListener('input', renderMetrics);
			$intervalToilettes.addEventListener('input', () => {
				const v = clamp(parseInt($intervalToilettes.value || '0', 10), 0, 240);
				$intervalToilettes.value = v; state.intervalToilettes = v; renderMetrics();
			});
			$addBtn.addEventListener('click', () => {
				const newStep = {id: `custom_${Date.now()}`, label: 'Activité à faire', minutes: 15, min: 0, max: 600, enabled: true};
				state.steps.push(newStep);
				rebuildList();
				renderMetrics();
			});
			$resetBtn.addEventListener('click', () => {
				state.steps = structuredClone(DEFAULT_STEPS);
				state.intervalToilettes = DEFAULT_INTERVAL_TOILETTES;
				$intervalToilettes.value = DEFAULT_INTERVAL_TOILETTES;
				setDefaultDeparture();
				rebuildList();
				renderMetrics();
				saveState(); // par profil
			});

			// Boutons profils
			$newProfileBtn.addEventListener('click', createProfile);
			$renameProfileBtn.addEventListener('click', renameCurrentProfile);
			$deleteProfileBtn.addEventListener('click', deleteCurrentProfile);

			// Tick 1s
			setInterval(() => {
				const dep = nextDateForTime($departureTime.value || '08:25');
				renderCountdown(dep);
				const now = new Date();
				const minUntilDep = Math.round((dep - now) / 60000);
				const total = totalMinutes();
				const slackMin = minUntilDep - total;
				$slack.textContent = minutesToHm(slackMin);
				$slack.classList.toggle('text-success', slackMin >= 0);
				$slack.classList.toggle('text-danger', slackMin < 0);
				$latestStartRel.textContent = relativeFromNow(new Date(dep.getTime() - total * 60000));
				if (state._intervalApplies) {
					$intervalStatus.textContent = '(appliqué)';
					$intervalStatus.classList.remove('text-danger'); $intervalStatus.classList.add('text-success');
				} else {
					$intervalStatus.textContent = "(non appliqué car ordre/état ne le permet pas)";
					$intervalStatus.classList.remove('text-success'); $intervalStatus.classList.add('text-danger');
				}
			}, 1000);
		}

		document.addEventListener('DOMContentLoaded', init);
	</script>
</body>

</html>